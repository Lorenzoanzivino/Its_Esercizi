========================================================================================================================================================================================
üêç APPUNTI PYTHON üêç
========================================================================================================================================================================================


üß† LEZIONE 3/1: IF, ELIF, ELSE
    Condizionali e Flusso di Esecuzione :

        Sintassi base:

            if (condition1):
                # code to execute if the condition1 is True
            elif (condition2):
                # code to execute if the condition1 is False and condition2 is True
            else:
                # code to execute if all conditions are False

        ‚úÖ Esempio 1:

        n = int(input("Digita un numero: "))
        if n == 5:
            print(f"{n} √® uguale a 5!")
        else:
            print(f"{n} √® diverso da 5!")

        ‚úÖ Esempio 2:

        n = int(input("Digita un numero: "))
        if n == 5:
            print(f"{n} √® uguale a 5!")
        else:
            if n % 2 == 0:
                print(f"{n} √® diverso da 5 ma √® pari")

        ‚úÖ Esempio 3:

        n = int(input("Digita un numero: "))
        if n == 5:
            print(f"{n} √® uguale a 5!")
        elif n % 2 == 0:
            print(f"{n} √® diverso da 5 ma √® pari")
        else:
            print(f"{n} √® diverso da 5 ed √® dispari")

üîÅ LEZIONE 3/2: WHILE, FOR
    Cicli di Ripetizione :

        1¬∞ Modo: Print Ripetuti

            print("Hello World!")
            print("Hello World!")
            print("Hello World!")

        2¬∞ Modo: WHILE

            i = 1
            while i <= 5:
                print("Hello World!")
                i += 1

        3¬∞ Modo: FOR

            for i in range(5):
                print("Hello World!")

            Stampare numeri da 1 a 10:

            for i in range(1, 11):
                print(i)

            Stampare solo i numeri dispari da 1 a 10:

                for i in range(1, 11, 2):
                    print(i)

üóÉÔ∏è LEZIONE 3/3: COLLECTION
    Liste, Set, Dizionari

        Liste:

            lista = [1, 2, 3, 4, "A", "a"]

        Modifiche alla lista:

            lista.append("new")  # Aggiunge "new"
            lista.remove("new")  # Rimuove "new"
            lista.pop(4)  # Rimuove l'elemento in posizione 4
            lista.pop()  # Rimuove l'ultimo elemento
            lista.extend([7, 8])  # Aggiunge [7, 8] alla lista

        Set (senza ordine, no duplicati):

            myset = {1, 2, 3, 4, "a"}
            myset.add("new")  # Aggiunge "new"
            myset.remove("new")  # Rimuove "new"
            myset.pop()  # Rimuove il primo elemento

        Dizionari (chiave: valore):

            mydict = {"A": 1, "B": 2.0}
            mydict["new"] = 3  # Aggiunge o modifica un valore
            mydict.pop("new")  # Rimuove la chiave "new"

üéØ LEZIONE 3/4: MATCH STATEMENT
    Esempi di uso di Match

        Posizione Gara:

            n = int(input("Inserisci la posizione finale: "))
            match n:
                case 1:
                    print(f"{n}st!")
                case 2:
                    print(f"{n}nd!")
                case 3:
                    print(f"{n}rd!")
                case _:
                    print(f"{n}th!")

        Esempio con Tuple:

            point = (3, 5)
            match point:
                case (0, 0):
                    print("Origine")
                case (x, 0):
                    print(f"Punto sull'asse X: ({x}, 0)")
                case (0, y):
                    print(f"Punto sull'asse Y: (0, {y})")
                case _:
                    print(f"Punto generico: {point}")

========================================================================================================================================================================================


üß† LEZIONE 4 ‚Äì Problem-Solving, Errori & Funzioni in Python
    üîç Cosa imparerai oggi

        ‚úÖ Cos'√® una funzione

        ‚úÖ Come si definisce e si utilizza

        ‚úÖ Differenza tra print() e return

        ‚úÖ Parametri, input, output

        ‚úÖ Come restituire uno o pi√π valori

        ‚úÖ I diversi modi per passare argomenti a una funzione

    üß© Cos'√® una funzione?

        Una funzione √® un blocco di codice riutilizzabile che esegue un compito specifico.
        üìå A cosa serve una funzione?

            Organizza il codice in modo chiaro e ordinato üßπ

            Evita di scrivere codice ripetitivo üîÅ

            Rende pi√π facile la manutenzione del programma üîß

        üß± Struttura base di una funzione

        # Definizione della funzione
        def saluta(nome: str) -> str:
            return "Ciao, " + nome

        # Chiamata della funzione
        print(saluta("Luca"))  # Output: Ciao, Luca

        üìå Nota: def √® la parola chiave per definire una funzione.
        ‚öôÔ∏è Esempio pratico ‚Äì Funzione per sommare un intervallo

        üßÆ Obiettivo: sommare i numeri da a a b (inclusi).

            def sumInRange(a: int, b: int) -> int:
                result = 0
                for i in range(a, b + 1):
                    result += i
                return result

            print(f"La somma tra 1 e 10 √®: {sumInRange(1, 10)}")
            print(f"La somma tra 20 e 37 √®: {sumInRange(20, 37)}")
            print(f"La somma tra 35 e 49 √®: {sumInRange(35, 49)}")

        üéØ Puoi anche salvare il risultato in una variabile:

        mysum = sumInRange(1, 10)
        print(f"Risultato salvato: {mysum}")

        üÜö Return vs Print üßæ
            ‚ú® return

                Ritorna un valore che pu√≤ essere salvato o utilizzato in un'altra parte del programma.

            üñ®Ô∏è print

                Mostra solo qualcosa a schermo, ma non restituisce nulla al codice.

            def subtract(a, b):
                return a - b

            print(subtract(4, 1))  # ‚úÖ Output: 3
            subtract(4, 1)          # ‚ùå Non vedrai nulla

        üö´ Funzioni che NON restituiscono nulla

            def greet(name: str) -> None:
                print(f"Hello {name}!")

            greet("Angela")
            # Output: Hello Angela!

            print(type(greet("Angela")))  # <class 'NoneType'>

        üìå -> None indica che non restituisce nulla.
        üîÅ Funzioni che restituiscono pi√π valori
        1Ô∏è‚É£ Restituire una tuple

        def operations(a: int, b: int) -> tuple[int, int]:
            somma = a + b
            differenza = a - b
            return somma, differenza

        x, y = operations(10, 5)
        print("Somma:", x)          # Somma: 15
        print("Differenza:", y)     # Differenza: 5
        print(type(operations(10, 5)))  # <class 'tuple'>

        2Ô∏è‚É£ Restituire una lista

            def get_coordinates(x: float, y: float) -> list[float]:
                return [x, y]

            coords = get_coordinates(12.5, 45.8)
            print(coords[0], coords[1])  # Output: 12.5 45.8
            print(type(coords))          # <class 'list'>

        3Ô∏è‚É£ Restituire un dizionario

            def get_user(name: str, role: str) -> dict[str, str]:
                return {"name": name, "role": role}

            user = get_user("Alice", "Admin")
            print(user["name"])  # Output: Alice
            print(user["role"])  # Output: Admin
            print(type(user))    # <class 'dict'>

        üîÑ Passaggio di parametri a una funzione
        1Ô∏è‚É£ Per posizione (Ordine conta)

            def describe_person(name: str, age: int, city: str):
                print(f"{name} ha {age} anni e vive a {city}.")

            describe_person("Alice", 25, "Roma")

        2Ô∏è‚É£ Per parole chiave (Keyword arguments)

            describe_person(name="Alice", age=25, city="Roma")

        ‚úÖ In questo modo l‚Äôordine non √® importante.
        3Ô∏è‚É£ Con valori predefiniti (Default values)

            def greet(name: str, age: int = 18):
                print(f"Hi, my name is {name} and I'm {age} years old!")

            greet("Marco")           # Output: Hi, my name is Marco and I'm 18 years old!
            greet("Sara", 22)        # Output: Hi, my name is Sara and I'm 22 years old!


        üöÄ Conclusioni :

        üéØ Le funzioni ti permettono di:

            Scrivere codice ordinato e riutilizzabile.

            Eseguire compiti complessi in modo semplice.

            Migliorare la leggibilit√† e la manutenibilit√† del programma.

        üìò Le funzioni possono:

            Ricevere parametri in input

            Restituire uno o pi√π valori

            Essere richiamate pi√π volte


        Fare PULL da Github a VsCode:
            Comando: git pull ‚Äì oppure ‚Äú3 puntini‚Äù nella source di vscode e fare pull se ci sono modifiche.
            Per un progetto condiviso da zero: creo la repository, pubblica, aggiungo i collaboratori tramite Settings>Collaborators>Add people. 
            Se la repository la crea qualcuno: fare il pull da github a vscode, clonare il link della repository con git clone il link, salvare la repo nella cartella, modificare  o fare codici nuovi nella repository locale poi creare un nuovo branch cosi che il main branch rimarr√† intatto e lavorer√≤ nel nuovo branch. 
            Una volta finito tutto quanto, faccio il marge, unisco il nuovo branch con quello originale. Rischio di confliffi perche nel nuovo branch puoi modificare anche parte del main.
            Creare nuovo branch: cliccare master/main poi nella barra cliccare create new branch e scrivi branch1. 
            Ogni modifica dopo, saranno sul nuovo branch (clone della cartella)



        "Spiegazione esercizio 9 compito sul P-GRECO :
            ‚ÄúThe main program should call the function computePI to determine how many terms of the series are needed to obtain the
            following approximation:
            ‚Ä¢ œÄ ‚âà 3.14 (2 decimal digits)
            ‚Ä¢ œÄ ‚âà 3.141 (3 decimal digits)
            ‚Ä¢ œÄ ‚âà 3.1415 (4 decimal digits)
            ‚Ä¢ œÄ ‚âà 3.14159 (5 decimal digits)
            Note: The program must iterate until it reaches each of the specified thresholds, counting the number of terms required and printing the results.‚Äù

            def computePI(approximation_value, decimal_digits)
            dividiamo il problema in 3 step:
            - 1. generalizzare la formula
            - 2. scrivere la funzione computerPI
            - 3. utilizza la funzione per calcolare le approssimazioni

            - 1 Generalizzare:  formula: œÄ = 4 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 + ‚Ä¶
            il denominatore di ogni termine ( frazione) cambia sempre con un incremento di +2 e il segno che cambia da positivo a negativo alternandosi.
            Dividere il primo problema in 2 sotto problemi (1.1:denominatore e 1.2:segno)
            1.1 denominatore:
            ‚Ä¢ The first term of the series is 4.
            ‚Ä¢ The second term of the series is 4/3.
            ‚Ä¢ The third term of the series is 4/5.
            ‚Ä¢ The fourth term of the series is 4/7.
            ‚Ä¢ The fifth term of the series is 4/9.
            ‚Ä¢ The sixth term of the series is 4/11, and so on.

            We need to initialize a counter i to 0 and define pi = 0.

            ‚Ä¢ For i = 0, we have the first term of the series, which is pi = 4.
            ‚Ä¢ For i = 1, we have the second term of the series, which is pi = 4/3.
            ‚Ä¢ For i = 2, we have the third term of the series, which is pi = 4/5.
            ‚Ä¢ For i = 3, we have the fourth term of the series, which is pi = 4/7.
            ‚Ä¢ For i = 4, we have the fifth term of the series, which is pi = 4/9.
            ‚Ä¢ For i = 5, we have the sixth term of the series, which is pi = 4/11.

            ‚Ä¢ i = 0
            pi = 4 = 4/1 = 4 / (0 + 1)
            ‚Ä¢ i = 1
            pi = 4/3 = 4 / (1 + 1 + 1)
            ‚Ä¢ i = 2
            pi = 4/5 = 4 / (2 + 2 + 1)
            ‚Ä¢ i = 3
            pi = 4/7 = 4 / (3 + 3 + 1)


            Thus, we found that 4/7 can be written as
            4 / (3 + 3 + 1) = 4 / (2 * 3 + 1),
            and since i = 3,

            cosi troviamo la FORMULA GENERALE 4 / (2 * i + 1).
            ‚Ä¢ i = 0
            pi = 4 = 4/1 = 4 / (2 * 0 + 1)
            ‚Ä¢ i = 1
            pi = 4/3 = 4 / (2 * 1 + 1)
            ‚Ä¢ i = 2
            pi = 4/5 = 4 / (2 * 2 + 1)
            ‚Ä¢ i = 3
            pi = 4/7 = 4 / (2 * 3 + 1)
            ‚Ä¢ i = 4
            pi = 4/9 = 4 / (2 * 4 + 1)
            ‚Ä¢ i = 5
            pi = 4/11 = 4 / (2 * 5 + 1)

            FUNZIONE
            # define a counter for while loop
            i:int = 0
            # define a term for pi for each iteration
            pi:float = 0.00
            # <= 5 perche ci servono solo 4 valori da traccia, quindi da 0 a 5
            while i <=5 :
                # print each term of the series
                print(f"4 / {2*i + 1}")
                # incrementing i by 1
                i +=1

            ORA TROVIAMO un MODO PER IL SEGNO
            Now, let's write the code that displays the obtained result in the output.
            # define a counter for while loop
            i:int = 0
            # define a term for pi for each iteration
            pi:float = 0.00
            while i <=6 :
                # if i is even, the term of the pi series is positive
                if i%2==0 :
                    print(f"+ 4 / {2*i + 1}")
                # if i is odd, the term of the pi series is negative
                else:
                    print(f"- 4 / {2*i + 1}")
                # incrementing i by 1
                i += 1"

            3. Use the function computePI(approximation_value, decimal_digits) to calculate 4 different approximations of œÄ.
            # calling computePI function to determine how many terms are needed to obtain 3.14 ( 152 terms)
            print(f"{computePI(3.14, 2)} terms are needed to compute a value of pi approximated to 3.14!")
            # calling computePI function to determine how many terms are needed to obtain 3.141 ( 916 terms)
            print(f"{computePI(3.141, 3)} terms are needed to compute a value of pi approximated to 3.141!")
            # calling computePI function to determine how many terms are needed to obtain 3.145 ( 7010 terms)
            print(f"{computePI(3.1415, 4)} terms are needed to compute a value of pi approximated to 3.1415!")
            # calling computePI function to determine how many terms are needed to obtain 3.1459 ( 130'658 terms)
            print(f"{computePI(3.14159, 5)} terms are needed to compute a value of pi approximated to 3.14159!")

========================================================================================================================================================================================


üß† LEZIONE 5: COMPREHENSION in Python

    Le comprehension sono un modo conciso e leggibile per creare nuove collezioni (liste, set, dizionari) partendo da iterabili esistenti, usando una sola riga di codice.
    üî¢ 1. List Comprehension

    üßæ Sintassi:

        [espressione for item in iterabile if condizione]

        ‚úîÔ∏è Rimpiazza i loop tradizionali, mantenendo il codice pi√π compatto.
        ‚úÖ Esempio base: quadrati dei numeri pari

        Versione tradizionale:

        squares = []
        for x in range(10):
            if x % 2 == 0:
                squares.append(x**2)

        Versione con comprehension:

        squares = [x**2 for x in range(10) if x % 2 == 0]

    üî† Esempio: convertire una lista di nomi in maiuscolo

        names = ["alice", "bob", "carol"]
        uppercase_names = [name.upper() for name in names]
        # Output: ['ALICE', 'BOB', 'CAROL']

        üì¶ Esempio: flatten di una lista di liste

        matrix = [[1, 2], [3, 4]]
        flat = [num for row in matrix for num in row]
        # Output: [1, 2, 3, 4]

    üü£ 2. Set Comprehension

        üßæ Sintassi:

            {espressione for item in iterabile if condizione}

            ‚úîÔ∏è Restituisce un set (insieme) con valori unici.
            üîÅ Esempio: lunghezze uniche di parole

            words = ["hi", "hello", "hey", "hi"]
            unique_lengths = {len(word) for word in words}
            # Output: {2, 3, 5}

    üü† 3. Dictionary Comprehension

        üßæ Sintassi:

            {chiave: valore for item in iterabile if condizione}

            ‚úîÔ∏è Crea un dizionario usando logica iterativa.
            üî¢ Esempio: mappare numeri al loro quadrato

            squares_dict = {x: x**2 for x in range(5)}
            # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

    ‚ö†Ô∏è Quando evitare le comprehension

        üö´ Non usarle se:

            ‚úÖ Rovinano la leggibilit√† del codice

            ‚úÖ Devono modificare lo stato di variabili gi√† esistenti

            ‚úÖ Sono troppo annidate (nested) e diventano difficili da capire

        üìå Quando usarle

            ‚úÖ Perfette per:

                Creare nuove liste, set o dizionari in modo rapido

                Applicare filtri e trasformazioni agli elementi

                Migliorare il codice se mantengono chiarezza + sintesi

========================================================================================================================================================================================


üè´ LEZIONE 6/1: CLASSI
    Introduzione alle Classi e Oggetti

    Classe persona:
    La classe persona √® una struttura che rappresenta una persona con attributi come nome, cognome e data_nascita.

        class persona:
            def __init__(self, nome: str, cognome: str, data_nascita: str):
                self.nome = nome
                self.cognome = cognome
                self.data_nascita = data_nascita

    Classe studente (ereditariet√†):
    La classe studente estende la classe persona utilizzando la superclasse per ereditare gli attributi di persona.

        class studente(persona):
            def __init__(self, nome, cognome, data_nascita, corso, **kwargs):
                super().__init__(nome, cognome, data_nascita, **kwargs)
                self.corso = corso

    Super() permette di accedere al costruttore della classe base persona per ereditare i suoi attributi.

    Creazione di oggetti:

        Esempio di creazione di oggetti:

            studente_1 = studente(nome="Erik", cognome="Crow", data_nascita="12/12/1980", corso="Informatica")
            persona_1 = persona("Eric", "Crow", "12/12/1980")
            persona_2 = persona("Alice", "Smith", "01/01/1990")

            print(persona_1.nome)
            print(persona_2.nome)
            print(persona_2.data_nascita)

    üîë Concetto di self

        Self √® una convenzione utilizzata come primo parametro nei metodi di una classe. Permette di accedere agli attributi e ai metodi dell'istanza corrente.

    ‚öôÔ∏è Concetti Chiave delle Classi

        Le Classi sono come stampi: Le classi definiscono un modello per creare oggetti. Ogni oggetto creato dalla classe avr√† gli attributi e i metodi definiti dalla classe stessa.

        Ereditariet√†: Consente di creare nuove classi che "ereditano" comportamenti e attributi da una classe base.

        Esempio:
        La classe Studente eredita gli attributi di Persona (come age, height), ma aggiunge anche i suoi attributi come matrNr, university, etc.

    üîÑ Esempi di Metodi Speciali in Python

        Metodo __str__:
        Questo metodo permette di definire una descrizione personalizzata per l'oggetto.

        class Persona:
            def __init__(self, name, age):
                self.name = name
                self.age = age

            def __str__(self):
                return f"{self.name}, {self.age} years old"

        p = Persona("Luca", 30)
        print(p)  # Output: Luca, 30 years old

        Metodo __call__:
        Questo metodo permette di usare un oggetto come se fosse una funzione.

        class Greeter:
            def __init__(self, message):
                self.msg = message

            def __call__(self):
                return f"Hello {self.msg}"

        g = Greeter("Alice")
        print(g())  # Output: Hello Alice

    ‚öñÔ∏è Buone Pratiche e Convezioni

        Nomi delle classi: Le classi dovrebbero avere la prima lettera maiuscola, e se ci sono pi√π parole, la prima di ogni parola deve essere maiuscola. Esempio: Person, PersonExchange.

        Inizializzazione degli oggetti (__init__):
        Il metodo __init__ √® il costruttore, utilizzato per inizializzare gli oggetti della classe. Gli attributi vengono creati tramite self.

        Encapsulation (Incapsulamento):
        Le variabili con due underscore (__) davanti sono considerate private, quindi non dovrebbero essere modificate direttamente dall'esterno della classe.

        Esempio:

            class Persona:
                def __init__(self, name, age):
                    self.__name = name
                    self.__age = age

        Getter e Setter:
        Le funzioni getter e setter sono utilizzate per ottenere e impostare i valori degli attributi. Servono per proteggere l'accesso ai dati sensibili.

üßë‚Äçüè´ LEZIONE 6/2: CLASSI (Gestione di attributi e metodi) üêç

    In questa lezione esploreremo come gestire attributi e metodi in Python, con particolare attenzione agli attributi pubblici, privati, metodi statici e metodi di classe.
    üîë Attributi Pubblici üîë

    Gli attributi pubblici sono accessibili da qualsiasi parte del programma. Tuttavia, l'uso di attributi pubblici pu√≤ essere rischioso, poich√© chiunque pu√≤ modificarli senza restrizioni.
    Esempio di Attributo Pubblico:

        class Animal:
            def __init__(self) -> None:
                self.name: str = "Generic Animal"  # Public attribute

        animal: Animal = Animal()
        print(animal.name)  # Output: "Generic Animal"

        animal.name = "It's a dog"  # MODIFICA l'attributo pubblico 'name'
        print(animal.name)  # Output: "It's a dog"

    Problemi degli attributi pubblici:

        Nessuna protezione: chiunque pu√≤ leggere o modificare l'attributo.

        Nessun controllo su tipo o validazione.

        Potenziali bug dovuti a modifiche non intenzionali.

    üö´ Attributi Privati üö´

        Un approccio pi√π sicuro √® utilizzare attributi privati, che possono essere accessibili solo all'interno della classe. Questo si ottiene utilizzando il prefisso con doppio underscore __.
        Esempio di Attributo Privato (senza getter):

        class Animal:
            def __init__(self) -> None:
                self.__name: str = "Generic Animal"  # Private attribute

        animal: Animal = Animal()
        print(animal.name)  # Errore: non accessibile direttamente

        Python e Name Mangling:
        Python esegue il name mangling, cambiando internamente __name in _NomeClasse__name. Non √® veramente privato, ma scoraggia l'accesso esterno.

    üîë Utilizzo di Getter e Setter per Attributi Privati üîë

        Per rendere un attributo privato accessibile in modo controllato, si utilizzano i metodi getter e setter.
        Esempio con Getter:

        class Animal:
            def __init__(self) -> None:
                self.__name: str = "Generic Animal"  # Private attribute
            
            # Getter per 'name'
            def get_name(self) -> str:
                return self.__name

        animal: Animal = Animal()
        print(animal.get_name())  # Output: "Generic Animal"

    üõ†Ô∏è Metodi Statici e Attributi di Classe üõ†Ô∏è

        I metodi statici e gli attributi di classe sono concetti utili quando hai bisogno di metodi o variabili che non dipendono dall'istanza della classe, ma sono condivisi da tutte le istanze.
        ‚öôÔ∏è Attributi di Classe ‚öôÔ∏è

        Gli attributi di classe sono condivisi da tutte le istanze della classe. Sono utili per comportamenti comuni o costanti che non dipendono dall'istanza.
        Esempio di Attributo di Classe:

        class Persona:
            popolazione: int = 0  # Attributo di classe pubblico

            def __init__(self, nome: str) -> None:
                self.__nome: str = nome  # Attributo privato
                Persona.popolazione += 1

        print(Persona.popolazione)  # Output: 0
        persona1: Persona = Persona("Alice")
        print(Persona.popolazione)  # Output: 1
        persona2: Persona = Persona("Bob")
        print(Persona.popolazione)  # Output: 2

    üìê Metodi Statici üìê

    I metodi statici non accedono n√© all'istanza n√© alla classe. Sono utili per operazioni che non richiedono la modifica o l'interazione con gli attributi della classe.
    Esempio di Metodo Statico:

    class Matematica:
        PI: float = 3.14  # Attributo di classe pubblico costante

        @staticmethod  # Decoratore per definire un metodo statico
        def area_cerchio(raggio: float) -> float:  # Metodo Statico
            return Matematica.PI * raggio * raggio

    print(Matematica.PI)  # Output: 3.14
    print(Matematica.area_cerchio(5))  # Output: 78.5

    üè´ Che Cos'√® un Metodo di Classe? üè´

    Un metodo di classe √® legato alla classe stessa, non a una sua istanza. √à definito con il decoratore @classmethod e prende cls come primo parametro invece di self.

        cls fa riferimento alla classe, non a una specifica istanza.

        Pu√≤ accedere e modificare gli attributi di classe.

    Esempio di Metodo di Classe:

    class Persona:
        __popolazione: int = 0  # Attributo di classe privato

        def __init__(self, nome: str) -> None:
            self.__nome: str = nome  # Attributo privato
            Persona.__popolazione += 1

        @classmethod
        def get_popolazione(cls) -> None:
            return cls.__popolazione  # Accede all'attributo di classe

    print(Persona.get_popolazione())  # Output: 0
    persona1: Persona = Persona("Alice")
    print(Persona.get_popolazione())  # Output: 1
    persona2: Persona = Persona("Bob")
    print(Persona.get_popolazione())  # Output: 2

    ‚ú® Riflessioni Finali ‚ú®

        Attributi Pubblici: Possono essere letti e modificati liberamente, ma possono causare problemi di integrit√†.

        Attributi Privati: Proteggono i dati e richiedono getter e setter per l'accesso.

        Metodi Statici e di Classe: Sono utili per operazioni che non dipendono dall'istanza della classe, come calcoli o valori condivisi.

========================================================================================================================================================================================


üßë‚Äçüè´ LEZIONE 8: EREDITARIET√Ä üå≥

    L'ereditariet√† permette di riutilizzare attributi e metodi di una classe base in una classe derivata. Vediamo i dettagli!
    üîÑ Riutilizzo di Attributi e Metodi con l'Ereditariet√† üêæ

    Con l'ereditariet√†, una classe derivata pu√≤ utilizzare metodi e attributi di una classe base.

        class Animal:
            def speak(self) -> None:
                print("The animal makes a sound")

        class Dog(Animal):
            def bark(self) -> None:
                print("Woof!")

        fido: Dog = Dog()
        fido.speak()  # Output: "The animal makes a sound"
        fido.bark()   # Output: "Woof!"

    üîß Uso di super() per il Costruttore della Classe Base üîß

        Con super(), puoi richiamare il costruttore della classe madre dalla classe figlia per evitare di duplicare il codice.
        Senza super():

            class Animal:
                def __init__(self, name: str) -> None:
                    self.name = name
                    print("Animal initialized")

            class Dog(Animal):
                def __init__(self, name: str) -> None:
                    self.name = name
                    print("Dog initialized")

            fido = Dog("Rudy")

            Output:

            Dog initialized

            Con super():

            class Animal:
                def __init__(self, name: str, color: str) -> None:
                    self.name = name
                    print("Animal initialized")

            class Dog(Animal):
                def __init__(self, name: str, color: str) -> None:
                    super().__init__(name, color)
                    print("Dog initialized")

            fido = Dog("Rudy", "black")

            Output:

            Animal initialized
            Dog initialized

    üê± Metodo Overriding üêæ

        Quando una sottoclasse implementa un metodo che ha lo stesso nome e gli stessi parametri di un metodo della classe base, la sottoclasse "sovrascrive" il metodo della classe base.

            class Animal:
                def speak(self) -> None:
                    print("The animal makes a sound")

            class Cat(Animal):
                def speak(self) -> None:
                    print("Meow!")

            kitty = Cat()
            kitty.speak()  # Output: "Meow!"

    üîí Attributi e Metodi Protetti üîí

        Gli attributi e i metodi protetti (con un singolo underscore _) sono destinati ad essere utilizzati solo all'interno della classe e dalle sue sottoclassi.
        Cosa sono i Membri Protetti?

        Attributi e metodi protetti sono prefissati da un singolo underscore _.

        Python non ha restrizioni di accesso, ma la convenzione √® di non modificare questi membri se non sei una sottoclasse.

        class Animal:
            def __init__(self) -> None:
                self._type = "Mammal"  # Protected attribute

            def _sound(self) -> None:  # Protected method
                print("Generic animal sound")

        class Dog(Animal):
            def describe(self) -> None:
                print(f"I am a {self._type}")  # Accessing protected attribute
                self._sound()  # Calling protected method

        fido = Dog()
        fido.describe()

        Output:

        I am a Mammal
        Generic animal sound

    ‚ú® Riflessioni Finali ‚ú®

        Ereditariet√†: Permette di creare nuove classi che estendono il comportamento di classi gi√† esistenti.

        Metodo Overriding: Fornisce un modo per personalizzare il comportamento dei metodi nelle classi derivate.

        Attributi e Metodi Protetti: Segnala agli sviluppatori che un membro √® destinato solo a essere utilizzato dalla classe e dalle sue sottoclassi, anche se Python non applica restrizioni vere e proprie.

        Con questi strumenti, puoi scrivere codice pi√π riutilizzabile, modulare ed estensibile! üöÄ

========================================================================================================================================================================================


üß© LEZIONE 9/1: RegEx ‚Äì Espressioni Regolari in Python

    Una RegEx (espressione regolare) √® una stringa speciale usata per trovare, verificare o estrarre pattern all‚Äôinterno di altre stringhe. Utile per filtrare email, codici, numeri, parole chiave, ecc.

        üìå Le RegEx funzionano solo su stringhe.

    üß± Componenti principali delle RegEx
    üîí 1. Anchors ‚Äì Ancore

        ^ ‚Üí Inizio riga

    ^Hello  # trova stringhe che iniziano con "Hello"

    $ ‚Üí Fine riga

        world$  # trova stringhe che finiscono con "world"

        ^Parola$ ‚Üí trova esattamente la parola "Parola"

    üîÅ 2. Quantificatori (1): *, +, ?

        * ‚Üí 0 o pi√π occorrenze

    abc*  # "ab", "abc", "abcc", ...

    + ‚Üí 1 o pi√π occorrenze

    abc+  # "abc", "abcc", ...

    ? ‚Üí 0 o 1 occorrenza (opzionale)

        abc?  # "ab" o "abc"

    üî¢ 3. Quantificatori (2): {}

        {n} ‚Üí esattamente n volte

    abc{3}  # "abccc"

    {n,} ‚Üí almeno n volte

    abc{2,}  # "abcc", "abccc", ...

    {n,m} ‚Üí da n a m volte

        abc{2,4}  # "abcc", "abccc", "abcccc"

    üé≠ 4. Wildcards ‚Äì Jolly

        . ‚Üí un qualsiasi carattere

    a.c  # "abc", "axc", "a7c"

    .* ‚Üí qualsiasi sequenza da 0 in poi

    a.*c  # "ac", "abc", "abbbc"

    .+ ‚Üí una o pi√π occorrenze

        a.+c  # "abc", "abbbc"

    ‚öôÔ∏è 5. Operators 1: |, (...), (?:...)

        | ‚Üí Alternativa (OR)

    cat|dog  # "cat" o "dog"

    (abc)+ ‚Üí Gruppo catturante, pu√≤ ripetersi

    (abc)+  # "abcabc"

    (?:abc) ‚Üí Gruppo non catturante

        (?:ab|cd)  # "ab", "cd", "abcd"

    üîç 6. Operators 2: Lookahead

        (?=...) ‚Üí Positive Lookahead: verifica cosa viene dopo, senza includerlo

    a(?=b)  # trova "a" seguita da "b"

    (?!...) ‚Üí Negative Lookahead: trova solo se non seguito da

        a(?!b)c  # trova "ac" ma non "abc"

    üî§ 7. Character Class 1 ‚Äì Classi di caratteri

        [ae] ‚Üí uno tra i caratteri

        gr[ae]y  # "gray", "grey"

        [a-z] ‚Üí lettere minuscole

        [A-Z] ‚Üí lettere maiuscole

        [0-9] ‚Üí cifre numeriche

    üö´ 8. Character Class 2 ‚Äì Negazioni e combinazioni

        [^abc] ‚Üí esclude "a", "b", "c"

        [a-zA-Z0-9_.] ‚Üí combinazione tipica per email

        [a-zA-Z0-9_.]+@[a-z]+\.[a-z]+

    üî£ 9. Character Class 3 ‚Äì Scorciatoie

        \d ‚Üí cifra (digit) ‚Üí [0-9]

        \D ‚Üí non cifra ‚Üí [^0-9]

        \w ‚Üí parola ‚Üí [a-zA-Z0-9_]

        \W ‚Üí non parola

        \s ‚Üí spazio bianco

        \S ‚Üí non spazio

        \b ‚Üí confine di parola

        \B ‚Üí non confine di parola

    üêç Usare RegEx in Python

    üëâ Devi importare il modulo:

    import re

    üîé Esempio 1 ‚Äì Email
        import re

        text = "My mail is marco@gmail.com"
        result = re.findall(r'\S+@\S+', text)
        print(result)
        # Output: ['marco@gmail.com']

    üìç Esempio 2 ‚Äì Match con maiuscola + minuscole
        import re

        text = "Rome Paris"
        result = re.match(r'[A-Z][a-z]+', text)
        print(result.group())  
        # Output: 'Rome'

    üßÆ Esempio 3 ‚Äì Estrai numeri
        import re

        text = "I have 20 cats and 3 dogs"
        numbers = re.findall(r'\d+', text)
        print(numbers)
        # Output: ['20', '3']

    üÜî Esempio ‚Äì Codice Fiscale (16 caratteri alfanumerici)

        regex = r'\b[A-Z0-9]{16}\b'

‚ú® LEZIONE 9/2: LAMBDA üêç
    Cos'√® una funzione Lambda? ü§î

    Una lambda √® una piccola funzione anonima, utile per definire logiche semplici in modo compatto. Pu√≤ avere pi√π argomenti, ma una sola espressione. Viene generalmente utilizzata come argomento di input per altre funzioni, come filter(), map() o sorted().

        Quando usarla:

            Quando la funzione √® temporanea e non richiede una definizione complessa.

            Quando si vuole evitare di scrivere una funzione tradizionale.

            Per passare una logica "inline" ad altre funzioni.

        Quando evitarla:

            Se la logica della funzione √® complessa o difficile da leggere.

            Quando la funzione deve essere riutilizzata pi√π volte nel codice.

            Quando compromette la leggibilit√† del codice.

    Sintassi della Lambda üîß

        La sintassi di una funzione lambda √® semplice:

        lambda arguments: expression

        Ecco alcuni esempi pratici:
            Esempio 1: Funzione Quadrato con Lambda üìê

            from typing import Callable
            # Lambda che calcola il quadrato di un numero
            square: Callable[[int], int] = lambda x: x ** 2
            print(square(5))  # Output: 25

            Funzione senza Lambda:

            def square(x: int) -> int:
                return x ** 2

            Esempio 2: Controllo Positivo o Negativo con Lambda ‚ûï‚ûñ

            from typing import Callable
            # Lambda che restituisce "Positivo" se il numero √® positivo, altrimenti "Zero o Negativo"
            positive_or_negative: Callable[[int], str] = lambda x: "Positivo" if x > 0 else "Zero o Negativo"
            print(positive_or_negative(5))  # Output: Positivo
            print(positive_or_negative(-3)) # Output: Zero o Negativo

            Funzione senza Lambda:

            def positive_or_negative(x: int) -> str:
                if x > 0:
                    return "Positivo"
                else:
                    return "Zero o Negativo"

    Uso della Lambda con filter() üîç

    La funzione filter() applica una condizione a ogni elemento di una lista e restituisce solo gli elementi che soddisfano tale condizione. Ecco come usare una lambda con filter():

        nums: list[int] = [1, 2, 3, 4, 5]
        evens: list[int] = list(filter(lambda x: x % 2 == 0, nums))
        print(evens)  # Output: [2, 4]

    Uso della Lambda con sorted() üìè

    La funzione sorted() ordina una lista. Utilizzando una lambda, √® possibile definire un criterio di ordinamento personalizzato:

        names: list[str] = ['Alice', 'Bob', 'Charlie']
        sorted_by_length: list[str] = sorted(names, key=lambda name: len(name))
        print(sorted_by_length)  # Output: ['Bob', 'Alice', 'Charlie']

    Uso di Lambda con le Espressioni Regolari (RegEx) üß©

    Le lambda possono essere usate con le espressioni regolari per operazioni pi√π dinamiche e complesse.

    Esempio 1: Filtrare Solo Numeri üî¢
        import re
        words: list[str] = ["abc123", "456", "43", "hello", "98abc", "test999"]
        only_digits: list[str] = list(filter(lambda x: re.fullmatch(r"\d+", x), words))
        print(only_digits)  # Output: ['456', '43']

        Descrizione: Qui la lambda filtra solo le stringhe che contengono soltanto numeri.
    
    Esempio 2: Moltiplicare Numeri in una Stringa ‚úñÔ∏è
        import re
        text: str = "Price: 100 dollars, Tax: 20 dollars"
        new_text: str = re.sub(r"\d+", lambda m: str(int(m.group()) * 2), text)
        print(new_text)  # Output: "Price: 200 dollars, Tax: 40 dollars"

        Descrizione: Questa lambda moltiplica ogni numero nella stringa per 2, sostituendo i valori originali.

    Conclusioni e Quando Usarla üí°
        Le lambda sono uno strumento potente e compatto per definire funzioni temporanee. Tuttavia, bisogna usarle con attenzione:

            Usala quando il codice √® semplice e facilmente comprensibile.

            Evitala quando la logica √® complessa o la funzione deve essere riutilizzata pi√π volte.

========================================================================================================================================================================================


üß† LEZIONE 13: FUNZIONI RICORSIVE
    üìã Esercizio: Countdown con while (senza variabili aggiuntive)
    üß© Traccia:

    ‚úçÔ∏è Scrivere una funzione Python chiamata countdown che:

        Prende un intero positivo n come input

        Stampa il conto alla rovescia da n a 0

        Se il numero √® negativo, stampa un messaggio di errore

        Deve usare solo un ciclo while e solo la variabile n (niente altre variabili!)

        Chiamare la funzione con n = -5 e n = 5

    ‚úÖ Output atteso:

    Error! Inserted number is negative!
    -------------------------------------------------
    5
    4
    3
    2
    1
    0

    üí° Soluzione con ciclo while:

    def countdown(n: int) -> None:
        if n >= 0:
            while n >= 0:
                print(n)
                n = n - 1
        else:
            print("Error! Inserted number is negative!")

    üîÅ Chiamate alla funzione:

    countdown(-5)
    print("-------------------------------------------------")
    countdown(5)

    üîÅ Funzioni RICORSIVE
        üß† Cos‚Äô√® una funzione ricorsiva?

        Una funzione ricorsiva √® una funzione che si richiama da sola per risolvere un problema suddividendolo in sottoproblemi pi√π semplici.
        üß± Struttura base della ricorsione:

            Caso base (terminazione) ‚Äì dove la funzione si ferma e non si richiama pi√π

            Passo ricorsivo ‚Äì dove la funzione richiama s√© stessa con un input modificato

        üß® Esempio: countdown ricorsivo
        ‚úçÔ∏è Traccia:

        Scrivere una funzione countdown ricorsiva che:

            Prende n come input

            Se n < 0 ‚Üí stampa errore

            Se n == 0 ‚Üí stampa 0 e si ferma

            Altrimenti ‚Üí stampa n e richiama s√© stessa con n-1

        ‚úÖ Codice:

        def countdown(n: int) -> None:
            # Step 1: caso base negativo
            if n < 0:
                print("Error! Inserted number is negative!")
            # Step 2: caso base n == 0
            elif n == 0:
                print(0)
            # Step 3: passo ricorsivo
            else:
                print(n)
                countdown(n - 1)

        üí¨ Esempio chiamata:

        countdown(-5)
        print("-------------------------------------------------")
        countdown(5)

        üìå Concetti chiave:

            üß± Caso base: condizione in cui non si richiama pi√π la funzione (es. n == 0)

            üîÅ Passo ricorsivo: quando la funzione si richiama con un nuovo valore (es. n - 1)

            ‚ö†Ô∏è Attenzione: senza caso base, la ricorsione va in loop infinito ‚û°Ô∏è errore RecursionError

        üìö Ricorda!

            Una funzione ricorsiva deve sempre avere:

                ‚ùó Un caso base

                üîÑ Un passo ricorsivo

            La ricorsione pu√≤ essere utile in problemi ripetitivi e strutturati (es. countdown, fattoriale, alberi, Fibonacci, ecc.)

========================================================================================================================================================================================


‚öôÔ∏è LEZIONE 14 : PYTEST (test python)

    üß™ Testing in Python
        Cos'√® il testing?

            Processo per verificare che software, app e siti funzionino correttamente.

            Risparmia tempo e denaro rilevando problemi prima che diventino critici.

        Unit test:

            Testano una singola ‚Äúunit√†‚Äù di codice, es. una funzione o metodo.

        Framework in Python:

            unittest (standard)

            pytest (pi√π potente e leggibile)

    ‚úÖ L'istruzione assert

        Serve a verificare che una condizione sia vera:
            assert 1 > 0  # non succede nulla
            assert 1 < 0  # solleva AssertionError

            Con messaggio personalizzato:

                n = 0
                assert 1 < n, 'The Condition is False'

    üì¶ Installazione di Pytest
        pip install pytest
        pytest --version

    üìÅ Struttura consigliata del progetto
        my_project/
        ‚îú‚îÄ‚îÄ weather.py
        ‚îî‚îÄ‚îÄ tests/
            ‚îî‚îÄ‚îÄ test_weather.py

            ‚ö†Ô∏è Non chiamare la cartella test/, ma tests/ per evitare conflitti con il modulo test di Python.

    üîπ Esempio base:
        weather.py

        def check_weather(temperature: float) -> str:
            if temperature > 20:
                return "hot"
            elif 10 < temperature <= 20:
                return "average"
            else:
                return "cold"

        test_weather.py

        from my_project.weather import check_weather

        def test_check_weather():
            assert check_weather(21.00) == "hot", "temperature > 20 should be 'hot'"

            ‚úÖ Output con . = test passato

            ‚ùå Output con F = test fallito

    ‚ö†Ô∏è Errori comuni nei test

        Funzioni che non iniziano con test_ non vengono eseguite.

        Pi√π assert in una funzione = un solo test, anche se fallisce una sola assert.

    ‚ôªÔ∏è @pytest.mark.parametrize
        Permette di testare una funzione con pi√π input/output senza ripetere il codice.

        import pytest
        from my_project.weather import check_weather

        @pytest.mark.parametrize("temperature, expected", [
            (21.00, "hot"),
            (13.00, "average"),
            (0.00, "cold"),
            (15.00, "cold")  # Questo fallir√†
        ])
        def test_check_weather(temperature, expected):
            assert check_weather(temperature) == expected

            Ogni coppia (input, expected) diventa un test separato.

            üëç Test pi√π leggibili e meno ripetitivi.

    üß∞ @pytest.fixture
        Usata per creare oggetti riutilizzabili nei test, ad es. istanze di classi.
        Esempio:
            import pytest
            from my_project.calculator import Calculator

            @pytest.fixture
            def calc():
                return Calculator()

            def test_add(calc):
                assert calc.add(2, 3) == 5

            def test_subtract(calc):
                assert calc.subtract(5, 2) == 3

                ‚úÖ Pi√π pulito, niente duplicazione di codice

                ‚úÖ Ottimo per setup di oggetti, file, connessioni ecc.

    ‚ñ∂Ô∏è Eseguire i test
        Tutti i test nella directory:
            pytest

        Modalit√† verbose:
            pytest -v

        Mostra il nome dei file, nomi delle funzioni testate, parametri (se usi parametrize), stato (PASSED/FAILED).

========================================================================================================================================================================================


üßæ LEZIONE 15 ‚Äì FILE ("Sequenza di Bytes")
    
    üìå Cos'√® un File:

        Un file √® una sequenza di byte memorizzata su disco. Viene utilizzato per salvare informazioni in modo persistente, anche dopo la chiusura del programma.
        üìÇ Struttura di un File

            HEADER (Intestazione):
                Contiene metadati, cio√® informazioni sui dati del file (es. formato, codifica, versione).
            CORPO (Body):
                Contiene il contenuto effettivo del file, cio√® i dati salvati.
            FINE DEL FILE (EOF ‚Äì End Of File):
                Una sequenza speciale (o flag) che segnala al sistema operativo che non ci sono altri dati da leggere.

    üêç Lavorare con i File in Python :
        üìò Funzione open() :
            Permette di aprire un file. Sintassi:
            file = open("percorso/file.txt", "modalit√†", encoding="utf-8")

        üìï Modalit√† di apertura:
            Modalit√† e Descrizione :
            "r"	Lettura (errore se il file non esiste)
            "w"	Scrittura (crea o sovrascrive)
            "a"	Aggiunta (scrive in fondo al file)
            "b"	Binario (es. "rb", "wb")

                ‚úÖ Esempio 1: Lettura da File :

                # Apertura in modalit√† lettura
                PATH = "example.txt"
                file = open(PATH, "r", encoding="utf-8")

                # Legge tutto il contenuto del file
                output = file.read()
                print(output)

                # Chiusura del file (obbligatoria)
                file.close()

    ‚ö†Ô∏è Gestione Manuale con try-finally :

        Utile per garantire la chiusura del file anche in caso di errore.

            file = open("example.txt", "a")  # modalit√† append
            try:
                file.write("Nuova riga\n")
            except Exception as e:
                print("Errore:", e)
            finally:
                file.close()  # Chiusura garantita

    üß† Context Manager: with :

        Python gestisce l'apertura e chiusura dei file automaticamente con with, evitando errori.

            with open("example.txt", "r", encoding="utf-8") as file:
                contenuto = file.read()
                print(contenuto)
            # Il file √® gi√† chiuso fuori dal blocco

    üìå Dietro le quinte: il context manager usa due metodi speciali:

        class MyResource:
            def __enter__(self):
                print("Entrato")
                return self

            def __exit__(self, exc_type, exc_value, traceback):
                print("Uscita automatica dal blocco")
                if exc_type:
                    print("Errore:", exc_value)
                return True  # Impedisce il propagarsi dell‚Äôeccezione

        with MyResource() as res:
            print("Dentro il blocco")

    üóÇÔ∏è File JSON (JavaScript Object Notation) :

        √à un formato testuale per rappresentare dizionari e liste.

        Molto usato per configurazioni e scambio dati tra programmi e sistemi.

    üìÅ Esempio: config.json :

        {
        "username": "admin",
        "theme": "dark",
        "version": 1.2
        }

    üì• Lettura e scrittura in Python:

        import json

        # Scrittura (dizionario ‚Üí file JSON)
        config = {"username": "admin", "theme": "dark"}
        with open("config.json", "w") as file:
            json.dump(config, file)

        # Lettura (file JSON ‚Üí dizionario)
        with open("config.json", "r") as file:
            config_data = json.load(file)
            print(config_data["theme"])

    üßë‚Äçüíª Best Practice

        Usa sempre with open(...) per evitare dimenticanze nella chiusura del file.

        Usa path relativi (es. "dati/file.txt"), cos√¨ il codice √® portabile su altri sistemi.

        Specifica l'encoding (es. "utf-8") per garantire la corretta lettura/scrittura di caratteri speciali.

        Gestisci gli errori con try-except per evitare crash in caso di file inesistenti o corrotti.

    üìé Riepilogo:

        ‚úÖ I file permettono la persistenza dei dati
        ‚úÖ Python offre strumenti potenti e semplici (open(), with, json)
        ‚úÖ I file JSON sono perfetti per strutturare configurazioni o dati leggibili dall‚Äôuomo

    üêû Debugger in Python :
        üìå Cos'√® un Debugger?
            Uno strumento che permette di:
                üõë Fermare l'esecuzione del programma in punti specifici (breakpoint).
                üîé Ispezionare il valore delle variabili.
                üîÑ Eseguire il codice riga per riga.
                üéØ Individuare bug e comportamenti inattesi.
                üîß Correggere errori logici e di flusso.

        üõ†Ô∏è Strumenti di Debugging in Python :
            pdb (Python Debugger) ‚Äì Debugger nativo, da riga di comando:
                Si importa con:
                import pdb; pdb.set_trace()
                Una volta attivato, puoi usare comandi interattivi:
                    n ‚Üí next: esegue la riga corrente e si ferma alla successiva.
                    c ‚Üí continue: continua fino al prossimo breakpoint.
                    l ‚Üí list: mostra le righe di codice attorno.
                    p var ‚Üí print: stampa il valore della variabile var.
                    q ‚Üí quit: esce dal debugger.

            Debugger integrato negli IDE :
                üéì Thonny ‚Äì molto semplice e didattico.
                üíª Visual Studio Code (VS Code) ‚Äì potente e molto usato:
                    Puoi mettere breakpoint cliccando a sinistra del numero di riga.
                    Funzioni utili: Step Over, Step Into, Watch Variables, Call Stack.
                üß± PyCharm ‚Äì offre strumenti avanzati di debugging e profiling.

        üîç Quando usare il debugger?
            Quando il programma non funziona come previsto.
            Quando hai bisogno di capire il flusso di esecuzione.
            Per trovare e correggere bug difficili da rilevare solo con print().

        üí° Confronto Debugger vs Print :

        üêç Metodo     ‚úÖ Vantaggi                        ‚ùå Svantaggi
           print()	     Facile, immediato,	                Poco flessibile, non interattivo.
           debugger	     Potente, interattivo, preciso,	    Pi√π tecnico, richiede tempo per imparare.

    üêû Debugger in Python con VSCode :
        ‚öôÔ∏è Come attivare il debugger in VS Code :
            Apri il tuo file .py in Visual Studio Code.
            In alto a destra clicca sull‚Äôicona verde "play con insetto" o su "Run and Debug" ‚ñ∂Ô∏èüêû.
            Dal menu a discesa, seleziona "Python: Debug Current File" (o in italiano "Python: Esegui debug del file corrente").
            Il debugger partir√† e appariranno nuovi pannelli e controlli utili.

        üéÆ Strumenti principali del Debugger in VS Code :

            üîß Strumento :	           üìù Funzione :

            ‚õî Breakpoint	          Clicca a sinistra del numero di riga per fermare l‚Äôesecuzione in quel punto.
            ‚ñ∂Ô∏è Continue (F5)	       Continua l‚Äôesecuzione fino al prossimo breakpoint.
            ‚è≠Ô∏è Step Over (F10)	       Esegue la riga attuale senza entrare dentro funzioni.
            ‚è¨ Step Into (F11)	      Entra dentro una funzione chiamata sulla riga corrente.
            ‚è´ Step Out (Shift+F11)	  Esegue il resto della funzione e torna al punto da cui era stata chiamata.
            üîç Variables / Watch	   Mostra le variabili e i loro valori aggiornati in tempo reale.
            üß≠ Call Stack	           Mostra la sequenza di chiamate delle funzioni (utile per capire da dove si arriva).
            üìå Watch	               Puoi aggiungere variabili specifiche da tenere d‚Äôocchio.
            üß™ Debug Console	       Una console interattiva per eseguire comandi Python live durante il debug.
            
        üí° Consigli pratici

            Usa breakpoint() nel codice per forzare un punto di stop.
            Usa Watch per monitorare variabili complesse (es. oggetti, liste).
            Se il codice √® lungo, aggiungi pi√π breakpoint per seguire l'esecuzione passo passo.
            Il debugger √® utile anche per studiare il comportamento di funzioni ricorsive, cicli, e branching logico (if/else).

========================================================================================================================================================================================


üö® LEZIONE 18/1: LE ECCEZIONI
    ‚ùó Cos'√® un'Eccezione?

        Un'eccezione in Python √® un evento che si verifica durante l'esecuzione del programma e che interrompe il normale flusso del codice.
        Python permette di gestire le eccezioni per evitare crash improvvisi ‚ö†Ô∏è
        üî• raise: sollevare un'eccezione manualmente

        La keyword raise viene usata per generare un'eccezione manualmente, ad esempio per segnalare che qualcosa non va nel programma.

        number = 10
        if number > 5:
            raise Exception(f"Number should not exceed 5. {number}")
        print(number)

        üìå Output:

        Exception: Number should not exceed 5. 10

        üß™ Blocco try-except-else-finally
        üîπ try: blocco che potrebbe generare un'eccezione
        üî∏ except: cosa fare se l‚Äôeccezione si verifica
        üü¢ else: viene eseguito solo se non si verifica alcuna eccezione
        üßπ finally: viene sempre eseguito, anche in caso di errore (utile per cleanup)
        ‚úÖ Esempio: gestione della divisione per zero

        try:
            result = 10 / 0
        except ZeroDivisionError:
            print("‚ö†Ô∏è Non puoi dividere per zero!")
        else:
            print(f"‚úÖ Il risultato √®: {result}")
        finally:
            print("üîö Operazione completata (con o senza errori)")

        üìå Output:

        ‚ö†Ô∏è Non puoi dividere per zero!
        üîö Operazione completata (con o senza errori)

        üßπ Blocco finally

        Viene eseguito sempre, utile ad esempio per:

            Chiudere file

            Liberare risorse

            Terminare una connessione

    üí° Creare Eccezioni Personalizzate :
        Puoi creare eccezioni tue, per casi specifici della tua applicazione, estendendo la classe Exception.

        class MiaEccezione(Exception):
            pass

        def controlla_valore(n):
            if n > 100:
                raise MiaEccezione("‚ùå Valore troppo alto!")
            else:
                print("‚úÖ Valore accettato")

        controlla_valore(150)

        üìå Output:

        MiaEccezione: ‚ùå Valore troppo alto!

    üß† Riepilogo concetti chiave:
        Concetto	                    Spiegazione
        raise	                        Solleva un'eccezione manualmente üö®
        try	                            Blocca il codice "a rischio"
        except	                        Gestisce l'errore in caso di eccezione
        else	                        Viene eseguito solo se nessuna eccezione √® stata sollevata
        finally	                        Viene sempre eseguito, utile per cleanup üßΩ
        Eccezioni personalizzate	    Create con classi che ereditano da Exception

========================================================================================================================================================================================


‚úÖ LEZIONE 18/2: LE ASSERZIONI in Python
    üîç Cosa sono le Asserzioni?

    Le asserzioni (assert) servono per verificare che una condizione sia vera in un certo punto del programma.

        Se la condizione √® vera: ‚úÖ il programma continua normalmente

        Se la condizione √® falsa: ‚ùå viene generata un'eccezione AssertionError

    Le asserzioni sono molto utili per il debug üêõ
    ‚ö†Ô∏è Non sono pensate per gestire input utente.
    üßæ Sintassi di base:

    assert condizione, "Messaggio opzionale"

    üí° Esempio pratico:

    x = 5
    assert x > 0, "‚ùå x deve essere positivo!"

    üìå Cosa succede:

        Se x > 0 ‚Üí programma continua ‚úÖ

        Se x <= 0 ‚Üí viene sollevata un‚Äôeccezione AssertionError con messaggio ‚ùå

    üß™ Perch√© usare assert?

        Per verificare precondizioni o postcondizioni

        Per assicurarti che il programma sia in uno stato atteso

        Per controllare il comportamento mentre sviluppi o testi il codice

    üßº Come disattivare tutte le asserzioni

    Quando il progetto √® pronto per la produzione (e non vuoi che gli assert abbiano effetto), puoi disattivarli dal terminale:

    python -O script.py

    üîµ Con -O (optimize):

        Tutte le asserzioni (assert) vengono ignorate

        Ideale per rilasci finali o ambiente di produzione

    üìå Confronto modalit√†:
        Comando	Effetto sugli assert
        python script.py	Asserzioni attive ‚úÖ
        python -O script.py	Asserzioni ignorate ‚ùå

    üß† Riepilogo concetti chiave:
        Concetto	        Descrizione
        assert	            Verifica una condizione e lancia un'eccezione se falsa
        Quando usarlo	    Per debug e controllo dello stato interno del programma
        Quando evitarlo	    Per input utente o logica di produzione
        Disattivazione	    Usa python -O per ignorare le asserzioni

========================================================================================================================================================================================


üö¢ LEZIONE 20 : DOCKER

    La piattaforma per il containerizzazione delle applicazioni.


    Docker √® una piattaforma che consente di sviluppare, spedire ed eseguire applicazioni in ambienti isolati chiamati contenitori.

    Spiegazione:
    Un contenitore √® un'unit√† leggera e portatile che contiene tutto il necessario per eseguire un'applicazione, come il codice, le librerie e le dipendenze. I contenitori possono essere eseguiti su qualsiasi macchina che supporti Docker, indipendentemente dal sistema operativo.

    Esempi:

        Esegui un'applicazione web in un contenitore Docker.

        Testa un'applicazione in un ambiente controllato senza preoccuparsi delle differenze tra i sistemi.

    Emoticon: üõ†Ô∏è
    üîß Componenti di Docker

    Sottotitolo: I pezzi fondamentali che fanno funzionare Docker.

    Descrizione:
    Docker si basa su diverse componenti chiave che lavorano insieme per creare e gestire i contenitori.

    Spiegazione:
    Le componenti principali di Docker sono:

        Docker Engine: Il motore che gestisce i contenitori.

        Immagini Docker: Modelli da cui i contenitori sono creati.

        Contenitori Docker: Le istanze di un'immagine, che eseguono il codice.

        Docker Hub: Il registro dove puoi trovare e condividere immagini Docker.

    Esempi:

        Utilizzare docker pull per scaricare un'immagine dal Docker Hub.

        Creare un contenitore con docker run a partire da un'immagine.

    Emoticon: ‚öôÔ∏è
    üîÑ Comandi principali di Docker

    Sottotitolo: I comandi che ti permettono di interagire con Docker.

    Descrizione:
    I comandi Docker ti permettono di costruire, eseguire, monitorare e gestire i contenitori.

    Spiegazione:
    Ecco alcuni comandi fondamentali:

        docker build: Costruisce un'immagine Docker.

        docker pull: Scarica un'immagine dal Docker Hub.

        docker run: Avvia un contenitore.

        docker exec: Esegui comandi all'interno di un contenitore in esecuzione.

    Esempi:

    docker run -d -p 8080:80 nginx

    Questo comando esegue il contenitore Nginx sulla porta 8080.

    Emoticon: üíª
    üìù Dockerfile

    Sottotitolo: Come creare un'immagine personalizzata.

    Descrizione:
    Un Dockerfile √® un file di testo che contiene le istruzioni per costruire un'immagine Docker.

    Spiegazione:
    Ogni comando nel Dockerfile √® eseguito durante il processo di build per creare un'immagine. Puoi definire la base, copiare i file e installare dipendenze.

    Esempi:

    FROM ubuntu:20.04
    WORKDIR /app
    COPY . .
    RUN apt-get update && apt-get install -y python3
    CMD ["python3", "app.py"]

    Emoticon: üìÑ
    üîó Docker Compose

    Sottotitolo: Gestire pi√π contenitori con un solo file.

    Descrizione:
    Docker Compose √® uno strumento che ti consente di definire e gestire applicazioni multi-contenitore in un file YAML.

    Spiegazione:
    Con Docker Compose, puoi configurare tutti i tuoi contenitori (web, database, ecc.) in un singolo file docker-compose.yml, semplificando la gestione di applicazioni complesse.

    Esempi:

    version: '3'
    services:
    web:
        image: nginx
        ports:
        - "8080:80"
    db:
        image: mysql
        environment:
        MYSQL_ROOT_PASSWORD: example

    Emoticon: üì¶
    üåç Vantaggi di Docker

    Sottotitolo: Perch√© dovresti usare Docker?

    Descrizione:
    Docker offre numerosi vantaggi, tra cui portabilit√†, efficienza e scalabilit√†.

    Spiegazione:
    Docker rende facile creare applicazioni portabili che possono essere eseguite su qualsiasi sistema operativo. I contenitori sono leggeri e isolano le applicazioni per evitare conflitti tra di esse.

    Esempi:

        Eseguire la stessa applicazione su Linux, Windows e macOS senza modifiche.

        Creare ambienti di sviluppo identici a quelli di produzione.

        # Percorso completo del file
            - its@its-Virtual-Machine:~/vscode_projects/Esercizi_ITS/4_Python/Lezione_20_docker/Esercizio3_slide20$

        # Comando per buildare il docker
            - docker build . -t my-numpy-app

        # Comando per stampare
            - docker run my-numpy-app python app.py

========================================================================================================================================================================================


üíª LEZIONE 22 : Shell Programming (home/ > scripts/ tutti file con codici terminale)

    üîç Cosa imparerai oggi
        ‚úÖ Cos'√® uno script
        ‚úÖ Differenza tra shell interattiva e shell di esecuzione
        ‚úÖ Come si esegue uno script
        ‚úÖ Uso delle variabili (locali e d‚Äôambiente)
        ‚úÖ Comando read
        ‚úÖ Operazioni aritmetiche in shell
        ‚úÖ Istruzioni di controllo (if, case, for, while)

    üìÑ Cos'√® uno Script?
        Uno script √® un file di testo che contiene una serie di comandi shell, eseguiti uno dopo l‚Äôaltro.
            üìå Estensione tipica: .sh
            üìå Interprete: la shell (di solito /bin/bash o /bin/sh)

        ‚úÖ Struttura base di uno script
            #!/bin/bash
            echo "Ciao, mondo!"

            üìå Il primo rigo #!/bin/bash si chiama shebang: indica alla shell quale interprete usare.

        üêö Shell di esecuzione
            La shell √® l‚Äôinterfaccia testuale tra utente e sistema operativo.
            Pu√≤ essere:
                Interattiva ‚Üí quando scrivi comandi uno per uno nel terminale.
                Scriptata (non interattiva) ‚Üí quando la shell esegue uno script.

    ‚ñ∂Ô∏è Esecuzione di uno Script:
        1Ô∏è‚É£ Rendi eseguibile lo script
            chmod +x mio_script.sh

            2Ô∏è‚É£ Esegui lo script
            ./mio_script.sh

            Oppure:
            bash mio_script.sh

    üîÅ Variabili locali:
        Si usano per salvare valori temporanei all‚Äôinterno dello script.
            nome="Mario"
            echo "Ciao $nome"

            üìå Senza spazi attorno a =
            üìå Per richiamarle: $variabile

    üåç Variabili d'ambiente:

        Sono visibili ai processi figli e all‚Äôambiente shell.
            Esempio:

            export PATH=$PATH:/nuovo/percorso

            export NOME="Marco"
            üìå Usa export per rendere una variabile globale

    ‚å®Ô∏è Read ‚Äì Input da tastiera:
        echo "Come ti chiami?"
        read nome
        echo "Ciao $nome"

        üìå read legge l‚Äôinput dell‚Äôutente e lo salva nella variabile.

    ‚ûï Operazioni Aritmetiche:
        Sintassi base:
            a=5
            b=3
            somma=$((a + b))
            echo "Risultato: $somma"

            üìå Usa $(()) per le operazioni :
                IL DOLLARO "$" PERMETTE DI ACCEDERE AL VALORE DELLA VARIABILE
            üìå Supporta +, -, *, /, %, ** (potenza)

    üîÄ Istruzioni di Controllo:
        ‚úÖ if
            x=10

            if [ $x -gt 5 ]; then
            echo "Maggiore di 5"
            else
            echo "Minore o uguale a 5"
            fi

            üìå Operatori: -eq, -ne, -gt, -lt, -ge, -le

    üßÆ case:
        read -p "Inserisci un numero: " num

            case $num in
            1) echo "Hai scelto uno" ;;
            2) echo "Hai scelto due" ;;
            *) echo "Altro valore" ;;
            esac

    üîÅ for:
        for i in 1 2 3; do
        echo "Numero: $i"
        done

    üîÇ while:
        x=1
        while [ $x -le 5 ]; do
        echo "x vale: $x"
        x=$((x + 1))
        done

    üöÄ Conclusioni:
        üéØ Con gli script Bash puoi:
        Automatizzare compiti ripetitivi
        Gestire file e directory
        Creare interazioni con l‚Äôutente
        Fare calcoli e controlli logici

        üìå Ogni comando che puoi scrivere nel terminale, lo puoi inserire in uno script!

    üõ†Ô∏è Esempio completo: script interattivo:
        #!/bin/bash

        echo "Come ti chiami?"
        read nome

        echo "Quanti anni hai?"
        read eta

        if [ $eta -ge 18 ]; then
        echo "$nome, sei maggiorenne."
        else
        echo "$nome, sei minorenne."
        fi

========================================================================================================================================================================================