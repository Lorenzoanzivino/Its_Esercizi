üñ•Ô∏è LEZIONE 1: Cenni su hardware e Sistemi Operativi

    1. Componenti dell'architettura di un elaboratore
        ‚ó¶ CPU (Central Processing Unit): √à composta principalmente da tre unit√†:
            ‚ñ™ ALU (Arithmetic Logic Unit): si occupa delle operazioni matematiche e logiche.
            ‚ñ™ Control Unit (CU): coordina il flusso di istruzioni e dati tra le varie componenti.
            ‚ñ™ Registri: sono piccole aree di memoria ultra-veloci situate all'interno della CPU, usate per memorizzare temporaneamente dati e istruzioni. La velocit√† della CPU √® misurata in GHz (gigahertz), che indica il numero di cicli di clock al secondo.

        ‚ó¶ RAM (Random Access Memory): Oltre ad essere volatile, la RAM √® anche dinamica (DRAM) o statica (SRAM). La DRAM √® pi√π economica ma pi√π lenta, mentre la SRAM √® pi√π veloce ma pi√π costosa. La RAM √® divisa in heap (memoria per variabili dinamiche) e stack (memoria per variabili locali).

        ‚ó¶ Memoria su disco (HDD/SSD):
            ‚ñ™ HDD: In un hard disk, i dati sono memorizzati su dischi magnetici rotanti. La velocit√† di lettura/scrittura √® limitata dal movimento fisico delle testine, ma gli HDD sono ideali per archiviazioni a lungo termine grazie al loro costo contenuto.
            ‚ñ™ SSD: Gli SSD sono basati su memoria flash NAND, quindi non hanno parti mobili, rendendoli molto pi√π veloci e resistenti agli urti. Hanno un ciclo di vita limitato in termini di scritture, ma sono sempre pi√π usati per il loro miglioramento nelle prestazioni.

    2. Sistema operativo
        ‚ó¶ Il sistema operativo fornisce un'interfaccia tra l'hardware e l'utente, gestendo l'allocazione delle risorse e la sicurezza. Ogni sistema operativo ha un kernel, che √® la parte fondamentale responsabile della gestione delle risorse hardware e dell'esecuzione dei processi. Il kernel pu√≤ essere monolitico (tutto in un unico blocco) o microkernel (separato in moduli).

    3. Comandi del sistema operativo
        ‚ó¶ ls: Visualizza il contenuto della directory corrente. L'uso di opzioni come ls -a mostra anche i file nascosti (quelli che iniziano con un punto).
        ‚ó¶ cd: Usato per navigare tra le directory. Esempio: cd .. ti porta alla directory superiore.
        ‚ó¶ touch: Crea un file vuoto o aggiorna la data di modifica di un file esistente. √à utile per creare file di log temporanei.
        ‚ó¶ mkdir: Serve per creare directory, importante per strutturare progetti o file system.
        ‚ó¶ rm: Rimuove file o directory. √à importante essere cauti con il comando, specialmente con rm -rf, che rimuove in modo ricorsivo e forzato tutte le directory e i loro contenuti.

    4. Creazione di una struttura standard di un progetto Python
        ‚ó¶ Una struttura di progetto ben definita in Python include file per il codice (solitamente una cartella src o project_name), test (cartella tests), e file di configurazione (requirements.txt, setup.py).
        ‚ó¶ Fondamentale avere un file README.md per documentare il progetto e un file .gitignore per escludere file non necessari dal controllo versione.

========================================================================================================================================================================================


üåê LEZIONE 7: Reti di Calcolatori ‚Äì Fondamenti e Principi

    1. Cos'√® una rete di calcolatori
        ‚ó¶ Le reti di calcolatori sono composte da due o pi√π dispositivi (computer, server, router, etc.) interconnessi che permettono la trasmissione di dati. Le reti possono essere cablate, wireless o un mix di entrambi, con la possibilit√† di essere collegate tra loro tramite modem, switch, router, o hub.

        ‚ó¶ I principali modi di trasmissione includono la trasmissione seriale (un bit alla volta) e la trasmissione parallela (pi√π bit contemporaneamente).

    2. Utilizzi delle reti
        ‚ó¶ Le reti sono essenziali per garantire la collaborazione remota, l'accesso a risorse condivise, e la comunicazione globale. Le moderne reti sono progettate per essere scalabili, permettendo la connessione di milioni di dispositivi in tutto il mondo, come nel caso delle reti sociali, delle applicazioni cloud e delle reti aziendali.

    3. Comunicazione point-to-point e broadcast
        ‚ó¶ La comunicazione point-to-point avviene tra due dispositivi con una connessione diretta (ad esempio, un collegamento tra un computer e una stampante). Questo tipo di comunicazione √® affidabile, ma non scalabile a livello di rete globale.

        ‚ó¶ La comunicazione broadcast √® utilizzata per inviare un messaggio a tutti i dispositivi su una rete, come nel caso di un router che invia pacchetti a tutti i dispositivi in una rete locale.

    4. Topologia
        ‚ó¶ Topologia ad albero: √® una combinazione della topologia a stella e della topologia a bus. Viene utilizzata in reti di grandi dimensioni in cui ci sono pi√π livelli di dispositivi.

        ‚ó¶ Topologia a maglia completa: ogni dispositivo √® connesso direttamente a tutti gli altri dispositivi della rete. Garantisce alta resilienza e ridondanza, ma √® costosa da implementare.

    5. Modello Client-Server
        ‚ó¶ Nel modello Client-Server, il server √® il nodo centrale che offre risorse o servizi (come file, applicazioni, database), mentre i client sono i dispositivi che accedono a queste risorse. I client inviano richieste HTTP o altre richieste di rete al server, che elabora la richiesta e restituisce una risposta. Questo modello √® usato per applicazioni web, email, e servizi di streaming.

    6. Modello Peer-to-Peer (P2P)
        ‚ó¶ In una rete P2P, i nodi sono simmetrici e tutti i dispositivi possono fungere sia da client che da server. Le risorse (file, video, ecc.) vengono distribuite direttamente tra gli utenti. I client P2P sono autonomi, il che significa che non c'√® un server centrale che gestisce le connessioni.

        ‚ó¶ Le applicazioni P2P sono particolarmente utili per sharing di file (es. BitTorrent), comunicazioni vocali e video (es. Skype), e in blockchain (dove la rete distribuisce il controllo e la gestione dei dati tra i vari nodi).

    7. Classificazione su scala geografica
        ‚ó¶ Le WAN (Wide Area Network) possono essere pubbliche (internet) o private (come le VPN aziendali). Le MAN (Metropolitan Area Network) sono utili per connettere edifici in una citt√† o universit√†, e le LAN (Local Area Network) sono utilizzate per connettere dispositivi all'interno di una singola struttura come un ufficio o una casa.

========================================================================================================================================================================================


üî¢ LEZIONE 10: Architettura ‚Äì Gestione delle Informazioni

    1. Gestione delle informazioni
        ‚ó¶ La gestione delle informazioni riguarda anche il concetto di Database Management System (DBMS), che √® un software che gestisce la creazione, l'archiviazione e il recupero delle informazioni in un database. 

        ‚ó¶ DBMS si occupano di operazioni come query (ricerca), inserimento, aggiornamento e eliminazione dei dati.

    2. Codice Binario
        ‚ó¶ Oltre a essere fondamentale per la rappresentazione numerica, il codice binario viene usato in sistemi digitali, dove ogni stato (acceso o spento) √® rappresentato da 1 o 0. Le porte logiche (AND, OR, NOT) sono utilizzate per costruire circuiti elettronici che elaborano i dati in binario.

    3. Codice ASCII
        ‚ó¶ ASCII √® anche utilizzato per rappresentare simboli di controllo come il carriage return (ritorno a capo), line feed (avanzamento linea), e tabulazione. Ogni codice ASCII occupa un byte (8 bit), e i caratteri non visibili sono utilizzati per il controllo del flusso di dati nei terminali.

    4. Dimensioni dei dati
        ‚ó¶ Le dimensioni dei dati vengono misurate in bit, byte e word (parola), che rappresentano unit√† di memorizzazione in un computer. La dimensione di una parola varia a seconda dell'architettura del computer, di solito 16, 32 o 64 bit.

        ‚ó¶ Il termine bitrate si riferisce alla quantit√† di dati che possono essere trasferiti in un dato periodo di tempo (ad esempio, 10 Mbps indica 10 megabit al secondo).

    5. Propriet√† del binario
        ‚ó¶ Il sistema binario ha numerosi vantaggi per la realizzazione di circuiti elettronici, come la semplicit√† nel design di porte logiche e la facilit√† con cui possono essere rappresentati stati elettronici (on/off, 1/0).

    6. Conversione binario-decimale
        ‚ó¶ Il metodo della divisione per 2 funziona dividendo ripetutamente un numero decimale per 2 e registrando i resti, che poi vengono letti al contrario.

        ‚ó¶ Esempio, per il numero 13:
            ‚ñ™ 13 √∑ 2 = 6 resto 1
            ‚ñ™ 6 √∑ 2 = 3 resto 0
            ‚ñ™ 3 √∑ 2 = 1 resto 1
            ‚ñ™ 1 √∑ 2 = 0 resto 1 Il numero binario di 13 √® 1101.

    7. Conversione decimale-binario
        ‚ó¶ Il metodo della divisione per 2 √® simile al metodo di conversione inversa. Si divide il numero decimale per 2, annotando il resto ad ogni passaggio. Il risultato finale sar√† la rappresentazione binaria del numero.

    8. Addizione e sottrazione binaria
        ‚ó¶ Addizione binaria: simile all'addizione decimale, ma con solo 0 e 1. Quando si somma 1 + 1 si ottiene 10, quindi un carry (riporto) deve essere aggiunto al bit successivo.

        ‚ó¶ Sottrazione binaria: quando si sottrae un numero binario pi√π grande da uno pi√π piccolo, si utilizza il complemento a due, che √® un modo per rappresentare i numeri negativi in binario.

    9. Algebra Booleana
        ‚ó¶ L'algebra booleana √® essenziale nella progettazione di circuiti digitali, per ottimizzare le operazioni logiche. Le equazioni booleane possono essere semplificate usando le leggi dell'algebra booleana per costruire circuiti pi√π efficienti e risparmiare risorse.

    10. Modello di Von Neumann
        ‚ó¶ Il modello di Von Neumann prevede che la memoria condivida lo spazio sia per i dati che per il programma in esecuzione. Questo modello ha portato all'idea dei registri di memoria e delle istruzioni di fetch per ottenere dati dalla memoria.

========================================================================================================================================================================================


üñ•Ô∏è LEZIONE 11: Von Neumann Model e Protocolli di rete
    üîó 1. Architettura degli Elaboratori ‚Äì CPU, Memoria e I/O
        1. Il Modello di Von Neumann: definisce una struttura base del computer, composta da tre blocchi principali:
            ‚ó¶ CPU (Central Processing Unit)
            ‚ó¶ Memoria
            ‚ó¶ Dispositivi di I/O (Input/Output)

            ‚ó¶ Questi elementi sono collegati tramite il Bus di Sistema, che si suddivide in:
                ‚ñ™ Bus Dati: Trasmette i dati tra i componenti (istruzioni, risultati, ecc.).
                ‚ñ™ Bus Indirizzi: Specifica le locazioni di memoria o periferiche I/O coinvolte nel trasferimento.
                ‚ñ™ Bus di Controllo: Trasporta segnali di controllo e sincronizzazione (es. segnali di lettura/scrittura, interrupt).

        2. Bus di Sistema
            ‚ó¶ Il Bus di Sistema √® il canale di comunicazione che collega la CPU, la memoria e le periferiche, permettendo:
                ‚ñ™ Il trasferimento di dati, indirizzi e segnali di controllo tra le componenti.

        3. CPU ‚Äì Unit√† di Elaborazione Centrale
            La CPU √® il "cervello" del computer, esegue istruzioni, elabora dati e coordina il funzionamento generale del sistema.
            a) Processing Unit ‚Äì Unit√† di Elaborazione
                ‚ó¶ ALU (Arithmetic Logic Unit)
                    ‚ñ™ Esegue operazioni aritmetiche (somma, sottrazione, ecc.) e logiche (AND, OR, NOT, XOR).
                ‚ó¶ Registri Temporanei (TEMP)
                    ‚ñ™ Memorie veloci per immagazzinare dati intermedi durante l‚Äôesecuzione delle istruzioni.

            b) Control Unit ‚Äì Unit√† di Controllo
                ‚ó¶ PC (Program Counter)
                    ‚ñ™ Contiene l‚Äôindirizzo della prossima istruzione da eseguire.
                ‚ó¶ IR (Instruction Register)
                    ‚ñ™ Memorizza temporaneamente l‚Äôistruzione corrente da eseguire.

        4. Ciclo di Istruzione (Instruction Cycle)
            Le fasi dell'esecuzione di un‚Äôistruzione sono:
                ‚ó¶ FETCH
                    ‚ñ™ La CPU preleva l‚Äôistruzione dalla memoria (usando il PC).
                    ‚ñ™ L‚Äôistruzione viene caricata nell‚ÄôIR.
                ‚ó¶ DECODE
                    ‚ñ™ L‚Äôunit√† di controllo interpreta l‚Äôistruzione e identifica l‚Äôoperazione da eseguire.
                ‚ó¶ EXECUTE
                    ‚ñ™ L‚Äôoperazione viene eseguita (es. calcolo ALU, trasferimento dati, ecc.).

        5. Memoria

            ‚ó¶ La memoria centrale (solitamente RAM) √® usata per memorizzare temporaneamente:
                ‚ñ™ Le istruzioni del programma in esecuzione
                ‚ñ™ I dati da elaborare
            ‚ó¶ Organizzazione della Memoria: composta da celle da 1 byte (8 bit). Ogni cella ha:
                ‚ñ™ Un valore (il contenuto, es. 10100010)
                ‚ñ™ Un indirizzo (es. 0001, 0010, ecc.)
            ‚ó¶ Operazioni Fondamentali
                ‚ñ™ FETCH: recupera un valore da una locazione di memoria.
                ‚ñ™ STORE: memorizza un valore in una locazione specifica.

        6. Registri MDR e MAR
            ‚ó¶ MDR (Memory Data Register)
                ‚ñ™ Registra temporaneamente i dati da leggere/scrivere in memoria.
                ‚ñ™ Funziona come buffer tra la CPU e la memoria.

            ‚ó¶ MAR (Memory Address Register)
                ‚ñ™ Contiene l‚Äôindirizzo della cella di memoria da leggere/scrivere.
                ‚ñ™ Viene utilizzato durante le operazioni FETCH e STORE.

        7. Operazioni di FETCH e STORE
            ‚ó¶ FETCH (lettura da una locazione A):
                ‚ñ™ MAR ‚Üê A
                ‚ñ™ Invio segnale di lettura
                ‚ñ™ MDR ‚Üê Dato letto
            ‚ó¶ STORE (scrittura del valore X nella locazione A):
                ‚ñ™ MDR ‚Üê X
                ‚ñ™ MAR ‚Üê A
                ‚ñ™ Invio segnale di scrittura

        8. Dispositivi di Input e Output

            Permettono l‚Äôinterazione del computer con l‚Äôesterno.
            a) Input:
                Funzione: Inviano dati al computer.
                Esempi: Tastiera, mouse, scanner, microfono, webcam.
                Funzionamento: Convertono segnali esterni in dati digitali.

            b) Output:
                Funzione: Mostrano i risultati dell‚Äôelaborazione.
                Esempi: Monitor, stampanti, altoparlanti, proiettori.
                Funzionamento: Convertono segnali digitali in forma percepibile (suono, immagine, stampa).

        9. Dispositivi di Input/Output
            Alcuni dispositivi possono sia ricevere sia inviare dati:
                ‚ñ™ Monitor Touchscreen
                ‚ñ™ Input: tocco dell‚Äôutente
                ‚ñ™ Output: visualizzazione su schermo
                ‚ñ™ Hard Disk Esterno
                ‚ñ™ Input: scrittura dati
                ‚ñ™ Output: lettura dati
                ‚ñ™ Modem
                ‚ñ™ Input: ricezione dati da Internet
                ‚ñ™ Output: invio dati verso Internet

    üîó 2. Computer Networks ‚Äì Protocols
        üìå Internetwork:
            ‚ó¶ Internetwork (Internet): insieme di reti diverse collegate tramite gateway.
            ‚ó¶ Ogni rete pu√≤ avere hardware e protocolli differenti.
            ‚ó¶ protocolli permettono la comunicazione tra dispositivi all‚Äôinterno e tra le reti.

        üß† Protocols
            ‚ó¶  Protocollo: insieme di regole predefinite che gestiscono la comunicazione tra dispositivi elettronici.
            ‚ó¶ Inizialmente centrati sull‚Äôhardware, oggi il focus √® sul software.

        üíª Central Role of Software
            ‚ó¶ Funzionalit√† moderne:
                ‚ñ™ Gestione dati, sicurezza, performance, cloud.
                ‚ñ™ Software sofisticato = alta adattabilit√†.

            ‚ó¶ Sicurezza:
                ‚ñ™ Software implementa firewall, crittografia, IDS.

            ‚ó¶ Compatibilit√†:
                ‚ñ™ Permette l‚Äôinteroperabilit√† tra hardware diversi.

        üß± Stack of Layers (Struttura a strati)
            I protocolli sono organizzati in livelli (es. OSI Model).
            Ogni livello (n) comunica col suo pari sull‚Äôaltra macchina attraverso il protocollo di livello n.
            ‚ó¶ I livelli servono:
                ‚ñ™ a semplificare il design,
                ‚ñ™ a nascondere i dettagli tecnici ai livelli superiori.

        üì¶ Network Communication (Analogia e Funzionamento)
        Analogia:
            ‚ó¶ Mittente ‚Üí messaggio tradotto e trasportato ‚Üí destinatario.
            ‚ó¶ Traduzioni = trasformazioni dei dati (es. crittografia).
            ‚ó¶ Ogni passaggio = livello del protocollo (es. traduttore = livello applicazione).

            ‚ó¶ Meccanismo:
                ‚ñ™ Sorgente (top-down): dati scendono i livelli con header/trailer aggiunti.
                ‚ñ™ Destinazione (bottom-up): ogni livello rimuove il proprio header/trailer.
                ‚ñ™ Comunicazione avviene grazie ai servizi del livello inferiore.

            ‚ó¶ Esempio tecnico (Livelli 5 ‚Üí 1):
                ‚ñ™ Layer 5 (Applicazione): invia messaggio M.
                ‚ñ™ Layer 4 (Trasporto): aggiunge header con seq. num, ACK, etc.
                ‚ñ™ Layer 3 (Rete): divide in pacchetti, header con IP.
                ‚ñ™ Layer 2 (Collegamento dati): frame con MAC + trailer (errore).
                ‚ñ™ Layer 1 (Fisico): invio su cavo o mezzo.

        üîå Connection-Oriented Services
            ‚ó¶ Caratteristiche:
                ‚ñ™ Affidabili (ACK, ritrasmissione, ordine garantito).
                ‚ñ™ Controllo di flusso.
                ‚ñ™ Handshake iniziale e chiusura.
                ‚ñ™ Usati in: email, banking.

            ‚ó¶ Handshake:
                ‚ñ™ Richiesta (A ‚Üí B)
                ‚ñ™ Risposta (B ‚Üí A)
                ‚ñ™ Conferma (A ‚Üí B)

            ‚ó¶ ACK Mechanism:
                ‚ñ™ A ‚Üí pacchetto ‚Üí B
                ‚ñ™ B ‚Üí ACK ‚Üí A
                ‚ñ™ Ritrasmissione se ACK non ricevuto

        ‚ö° Connectionless Services
            ‚ó¶ Caratteristiche:
                ‚ñ™ Nessun handshake, alta velocit√†.
                ‚ñ™ Meno affidabili (pacchetti persi o fuori ordine).
                ‚ñ™ Ogni pacchetto √® autonomo.
                ‚ñ™ Usati in: streaming, gaming.

========================================================================================================================================================================================


üì° LEZIONE 12: Fondamenti di Sistemi Operativi, Modello ISO/OSI, Livello Fisico, Livello Data Link

    3. Architetture dei Computer üíª Fondamenti di Sistemi Operativi ‚öôÔ∏è
        Firmware üñ•Ô∏è
            Il firmware √® un tipo di software incorporato all'interno di un componente elettronico. In questo contesto, per componente elettronico si intende qualsiasi circuito integrato intelligente presente in vari dispositivi, inclusi processori, schede grafiche, schede audio, schede di rete e periferiche come stampanti e monitor.
            La funzione principale del firmware √® inizializzare il componente e facilitare la sua interazione con altri componenti all‚Äôinterno del dispositivo. In pratica, il firmware fornisce al componente un set di interfacce e protocolli di comunicazione, permettendo di usare un linguaggio comune (comprendente sintassi e semantica) per comunicare efficacemente con gli altri componenti.
        
        Firmware/1 üîß
            Il termine firmware deriva dalla combinazione di "firm" e "ware", indicando che il firmware non √® facilmente modificabile dall‚Äôutente. Serve da ponte tra hardware e software, permettendo ai componenti hardware di comunicare e funzionare secondo le istruzioni del software.
            Il BIOS (Basic Input/Output System) √® un esempio noto di firmware nei computer. Risiede sulla scheda madre ed √® cruciale per gestire il processo iniziale di avvio del computer, inclusa l‚Äôinizializzazione dell‚Äôhardware e il caricamento del sistema operativo.
            Ogni dispositivo, che sia un PC desktop, un laptop, il computer di bordo di un‚Äôauto o il sistema interno di un aereo, contiene componenti fondamentali simili come la scheda madre. Questi componenti possono variare in dimensioni e specifiche tecniche, ma svolgono funzioni analoghe.
            Il firmware √® solitamente memorizzato in una memoria non volatile all‚Äôinterno del componente elettronico o del dispositivo, cio√® una memoria che mantiene i dati anche quando il dispositivo √® spento.
        
        Memoria Non Volatile üíæ

            Tipi comuni di memoria non volatile usati per memorizzare il firmware includono:
                ROM (Read-Only Memory): Usata tradizionalmente per il firmware, ma una volta scritta non pu√≤ essere modificata.
                EPROM (Erasable Programmable Read-Only Memory): Pu√≤ essere cancellata e riprogrammata usando luce UV, ma questo processo non √® comodo come le alternative moderne.
                EEPROM (Electrically Erasable Programmable Read-Only Memory): Pu√≤ essere cancellata e riprogrammata usando una carica elettrica, risultando pi√π flessibile rispetto all‚ÄôEPROM.
                Memoria Flash: Un tipo di EEPROM che pu√≤ essere cancellata e riscritta a blocchi, comunemente usata nei dispositivi moderni grazie alla sua flessibilit√† e maggiore capacit√† di archiviazione.
                Questi tipi di memoria sono integrati nel dispositivo, garantendo che il firmware sia sempre accessibile per inizializzare e controllare i componenti al momento dell‚Äôaccensione.
        
        Scheda Madre (Motherboard):
            La scheda madre √® la principale scheda a circuito stampato (PCB) in un computer o altro dispositivo elettronico che ospita e consente la comunicazione tra molti componenti elettronici cruciali.
                Hub Centrale: Funziona come hub centrale che collega tutte le parti del computer, permettendo loro di comunicare e lavorare insieme.
                Socket CPU: Contiene la sede dove si installa il processore (CPU).
                Slot di Memoria: Slot per moduli di memoria RAM, consentendo al computer di memorizzare temporaneamente dati per un accesso rapido
                BIOS/UEFI: Il firmware Basic Input/Output System (BIOS) o Unified Extensible Firmware Interface (UEFI) √® memorizzato sulla scheda madre e fornisce le istruzioni necessarie per il processo di avvio iniziale e l‚Äôinizializzazione hardware.

        Scheda Madre/2 üîå
            Slot di Espansione: Permettono l‚Äôaggiunta di schede aggiuntive, come schede grafiche, audio, di rete o altre periferiche.
            Connettori di Memoria: Connettori per dispositivi di memorizzazione, come hard disk e SSD.
            Connettori di Alimentazione: Connessioni per fornire energia alla scheda madre e ai suoi componenti dall‚Äôalimentatore.
            Connettori Periferici: Porte e connettori per periferiche come USB, jack audio, cavi di rete, e uscite video (HDMI, DisplayPort).

            In sintesi, la scheda madre √® la spina dorsale del computer, integrando tutti i componenti critici e assicurando che possano comunicare e funzionare efficacemente insieme.
        
        BIOS (Basic Input/Output System) üñ•Ô∏è
            Il BIOS √® un insieme di routine software che fornisce la struttura software di base permettendo al sistema operativo di interfacciarsi con l‚Äôhardware del dispositivo.
            Il BIOS √® memorizzato in un chip di memoria non volatile, quindi mantiene i dati anche senza alimentazione. Oggi, il BIOS √® solitamente memorizzato su memoria Flash o EEPROM saldata sulla scheda madre, che pu√≤ essere riscritta tramite procedure di aggiornamento.

        BIOS ‚Äì Fase di Avvio (Bootstrap) üöÄ
            Quando il dispositivo si avvia, prima che il sistema operativo venga caricato, il BIOS esegue varie funzioni chiave:
                Mostra la schermata di avvio, che permette all‚Äôutente di configurare alcune impostazioni basilari del BIOS.
                Inizia la routine di boot per caricare il sistema operativo, caricando progressivamente le parti essenziali del sistema operativo dalla partizione di avvio per portare il sistema a uno stato operativo stabile.
                Esegue i test POST (Power On Self Test) per verificare il corretto funzionamento dei componenti come scheda madre, processore e memoria.
                Configura le impostazioni hardware se non vengono rilevati errori gravi durante i test.
                Cerca il Master Boot Record (MBR) nel disco rigido o altro supporto di memoria dove √® memorizzato il sistema operativo.
                Legge il contenuto del MBR e passa il controllo al sistema operativo.
                Se la tabella MBR √® danneggiata, il disco potrebbe non avviarsi.

        UEFI (Unified Extensible Firmware Interface) üöÄ‚ú®
            UEFI √® un‚Äôinterfaccia firmware moderna progettata per inizializzare l‚Äôhardware e caricare il sistema operativo all‚Äôavvio.
            Vantaggi rispetto al BIOS:
                Interfaccia grafica (GUI) con supporto mouse, pi√π user-friendly.
                Boot Manager integrato per scegliere quale sistema operativo o boot loader eseguire.
                Supporto per driver caricati direttamente, migliorando compatibilit√† e prestazioni.
                Sicurezza migliorata con funzioni come Secure Boot.
                Modularit√† e possibilit√† di aggiornamenti o estensioni nel tempo.

        GPT (GUID Partition Table) üìÄ
            GPT √® un sistema moderno per la gestione delle partizioni su dischi rigidi o SSD, parte dello standard UEFI e successore del vecchio MBR.
                Usa GUID (Globally Unique Identifier), identificatori univoci globali per ogni partizione.
                Include header primario, voci di partizione e header secondario (backup).
                Offre maggiore sicurezza e flessibilit√† rispetto a MBR.

        Driver üñ±Ô∏è
            I driver sono programmi software che permettono al sistema operativo e ad altri software di comunicare con l‚Äôhardware.
                Funzionano da intermediari, traducendo comandi di alto livello del sistema operativo in azioni comprensibili dall‚Äôhardware.
                Sono installati nel sistema operativo e possono essere aggiornati frequentemente.

        Sistema Operativo (OS) üñ•Ô∏è
            Il sistema operativo √® il software fondamentale che gestisce tutte le operazioni del dispositivo, inclusi applicazioni, programmi, servizi e interazioni con l‚Äôutente.
            Posizionato tra l‚Äôhardware (incluso il firmware) e il livello applicativo, il sistema operativo astrae la complessit√† del computer per l‚Äôapplicazione.
            Compiti principali:
                Gestire i componenti hardware
                Eseguire applicazioni, programmi e servizi
                Interfacciarsi con le periferiche
                Facilitare l‚Äôinterazione con l‚Äôutente
                Esempi: Windows, GNU/Linux, macOS, Android, iOS.

        Classificazione dei Sistemi Operativi üóÇÔ∏è
            In base al tipo di elaborazione:
                Batch OS: esegue programmi senza interazione utente.
                Time-Sharing OS: esegue pi√π programmi simultaneamente con interazione.
                Real-Time OS: garantisce esecuzione in tempo reale senza ritardi.
                Embedded OS: integrato in hardware dedicato.
                Hypervisor OS: permette virtualizzazione, eseguendo pi√π OS insieme.

            In base alle funzionalit√†:
                Monolitici (Kernel grande, tutto integrato)
                Microkernel (Kernel minimale, servizi separati)

    üåê Reti di Computer
        üèóÔ∏è Architettura di Rete
            Definisce struttura e funzionamento di una rete tramite livelli e protocolli.
            Propriet√† di rete:
                Propriet√† privata (design indipendente dal produttore)
                Standard de facto (es. TCP/IP)
                Standard de iure (es. ISO/OSI)

        üìö Modello ISO/OSI
            Creato nel 1984 da ISO, standard ufficiale per descrivere le reti a 7 livelli.
            Principi:
                Ogni livello con astrazione e funzione chiara
                Minima informazione tra livelli
                Non troppi livelli o funzioni in uno

        üîå Livello Fisico
            Gestisce la trasmissione di bit su supporti fisici:
                Cavi rame (Ethernet, coassiale)
                Fibra ottica
                Radiofrequenze (Wi-Fi, Bluetooth)

        üì° Wi-Fi e Bluetooth
            Wi-Fi: frequenze 2.4/5/6 GHz, copertura ~100 m, LAN wireless.
            Bluetooth: 2.4 GHz, ~10-100 m, PAN (personal area network).
            Vantaggi: niente cavi, mobilit√† e facilit√† di connessione.

        üìä Frequenza e Banda
            Frequenza = oscillazioni al secondo (Hz).
            Banda (bandwidth) = intervallo di frequenze usate da un segnale.
            Banda definisce quanti dati si possono trasmettere al secondo (bps).

        ‚è≥ Prodotto Banda-Ritardo
            Quantit√† massima di dati in transito in rete.
            Banda = "larghezza tubo", Ritardo = "lunghezza tubo", prodotto = volume dati in viaggio.

        üîó Livello Data Link
            Trasferisce dati tra nodi vicini con controllo errori e gestione flusso.
            Funzioni:
                Framing (incapsulamento dati in frame)
                Rilevamento e correzione errori (es. CRC)
                Controllo flusso
                Indirizzamento MAC (indirizzi fisici)

        üîÑ LLC e MAC (Sotto-livelli Data Link)
            LLC: gestione errori e controllo flusso.
            MAC: controllo accesso al mezzo trasmissivo, evita collisioni.

        üõë Metodi di Controllo Flusso LLC
            Stop-and-Wait: invia un frame, aspetta conferma. Semplice ma lento.
            Sliding Window: invia pi√π frame prima di aspettare conferme. Pi√π efficiente ma complesso.

        üì∂ MAC e Controllo Accesso
            CSMA/CD: usato in Ethernet, rileva collisioni e ritrasmette.
            CSMA/CA: usato in Wi-Fi, evita collisioni aspettando canale libero.

        üîÄ Switch di Rete
            Dispositivo che smista dati tra dispositivi in LAN.
            Legge indirizzo MAC destinazione, inoltra frame alla porta corretta.
            Costruisce dinamicamente una tabella MAC con gli indirizzi e le porte.

========================================================================================================================================================================================


üõ†Ô∏è LEZIONE 16: Livelli di Rete, Trasporto, Sessione, Presentazione, Applicazione
    üì° Livello di Rete (Network Layer)
        √à il terzo livello del modello ISO/OSI e si occupa di inviare i dati tra dispositivi su reti diverse.
        Funzioni principali:
            üõ§Ô∏è Routing: trova il percorso migliore da mittente a destinatario
            üö¶ Forwarding: inoltra i pacchetti da un router all‚Äôaltro
            üÜî Indirizzamento logico: usa gli indirizzi IP per identificare i dispositivi
            üß© Frammentazione: divide pacchetti grandi in parti pi√π piccole e li ricompone alla destinazione

        üó∫Ô∏è Routing
            Path Determination: i router scelgono il percorso migliore usando tabelle e algoritmi (es. Dijkstra)
            Packet Switching: i pacchetti passano da un router all‚Äôaltro
            Next-Hop Forwarding: ogni router invia il pacchetto al router successivo fino alla destinazione finale

        üì¶ Commutazione di pacchetto (Packet Switching)
            Store-and-Forward: il router riceve tutto il pacchetto, lo controlla per errori e poi lo inoltra (‚úÖ pi√π sicuro, ma pi√π lento)
            Cut-Through: il router inoltra il pacchetto appena legge l‚Äôindirizzo di destinazione (‚ö° pi√π veloce, ma non controlla errori)

        üåê Indirizzamento Logico - IP
            IPv4: indirizzi a 32 bit (es. 192.168.1.1)
            Classi di indirizzi:
                A: grandi reti (es. 10.0.0.1)
                B: medie reti (es. 172.16.0.1)
                C: piccole reti (es. 192.168.1.1)
                D: multicast
                E: riservati

            Subnet Mask: divide indirizzo IP in parte di rete e parte host (es. 255.255.255.0)

        üîÑ NAT (Network Address Translation)
            Permette a pi√π dispositivi con indirizzi privati di accedere a Internet con un unico indirizzo pubblico (es. il router di casa).

        ‚öôÔ∏è Livello di Trasporto (Transport Layer)
            Gestisce la comunicazione end-to-end tra dispositivi:
                Suddivide i dati in segmenti
                Controlla errori e flusso dei dati
                Gestisce la connessione (apertura, mantenimento, chiusura)

        üîå Socket
            Interfaccia che combina indirizzo IP + porta per identificare una comunicazione specifica (es. 192.168.1.1:80).
            üí¨ Livello di Sessione (Session Layer)
            Gestisce le sessioni tra applicazioni:
                Mantiene e termina le connessioni
                Controlla il dialogo in modalit√† half-duplex (una direzione per volta) o full-duplex (due direzioni simultanee)

        üñºÔ∏è Livello di Presentazione (Presentation Layer)
            Traduce i dati tra formato applicativo e rete
            Cripta/decripta per la sicurezza üîí
            Comprimi i dati per ottimizzare la trasmissione üìâ

        üñ•Ô∏è Livello di Applicazione (Application Layer)
            Fornisce servizi di rete alle applicazioni, come:
                Trasferimento file
                Email
                Login remoto
                Accesso a risorse di rete

========================================================================================================================================================================================

‚öôÔ∏è LEZIONE 17 - Servizi e Funzioni del Sistema Operativo 
    4. Architetture dei Computer
        Servizi e Funzioni del Sistema Operativo
        Gestione dei Processi üñ•Ô∏è

        Un processo √® un‚Äôistanza di un programma in esecuzione. Su un sistema operativo multitasking, pi√π processi possono girare contemporaneamente.
        Il sistema operativo si occupa di:
            Creare e terminare processi
            Sospendere e riprendere processi
            Sincronizzare e far comunicare i processi
            Gestire situazioni di deadlock (blocchi)

        I processi possono fare system call (chiamate di sistema) per:
            Eseguire altri processi (exec)
            Creare copie di se stessi (fork)
            Inviare segnali tra processi (wait/signal)
            Terminare processi (kill)

        Gerarchia dei processi:
            Il primo processo (es. systemd o init) √® il padre di tutti gli altri, formando un albero padre-figlio.
            Ogni processo ha un PID (Process ID), un PPID (Parent PID), e un USERID (utente che lo esegue).

        Stati di un Processo ‚è≥
            Init: Processo appena caricato in memoria.
            Ready: Processo pronto, in attesa della CPU.
            Running: Processo in esecuzione.
            Waiting: Processo sospeso, in attesa di un evento (es. input da dispositivo).
            Swapped: Processo spostato in memoria virtuale (disco) in attesa di tornare in RAM.
            Zombie: Processo terminato ma ancora in memoria, in attesa che il padre lo ‚Äúliberi‚Äù.
            Terminated: Processo finito, memoria liberata.

        Gestione della Memoria Principale (RAM) üß†
            Assegna e libera memoria ai processi.
            Isola lo spazio di memoria di ogni processo per sicurezza e stabilit√†.
            Mappa gli indirizzi logici usati dai processi agli indirizzi fisici in RAM.
            Gestisce la memoria virtuale e il paging (spostamento di pagine tra RAM e disco).

        Isolamento e Mappatura della Memoria üîí
            Ogni processo ha un indirizzo virtuale che sembra continuo e privato.
            Il sistema operativo traduce gli indirizzi virtuali in indirizzi fisici reali.
            Vantaggi:
                Sicurezza: i processi non possono accedere alla memoria degli altri.
                Flessibilit√†: spazio virtuale pi√π grande della RAM fisica disponibile.
                Efficienza: il sistema ottimizza l‚Äôuso della memoria fisica.

        Memoria Virtuale e Paging üìÄ
            La memoria virtuale usa RAM + disco (swap) per simulare pi√π memoria.
            La memoria √® divisa in pagine.
            Se una pagina non √® in RAM (page fault), viene caricata dal disco.
            Quando la RAM √® piena, pagine meno usate vengono spostate su disco (swap out) per far spazio a pagine attive (swap in).

        Gestione del File System üìÇ
            Il file system √® un livello astratto che organizza i dati su memoria secondaria (dischi, SSD).
            I file sono sequenze di byte permanenti, organizzati in cartelle (directory).
            Le cartelle sono file speciali che puntano ad altri file (struttura ad albero).

            Esempi di percorsi file:
                Windows: C:\Tom\Data\one.txt (non case-sensitive)
                Linux/Unix: ~Tom/src/minimumSpanningTree.c (case-sensitive, usa ~ per cartella home)

        I processi possono:
            Creare, aprire, leggere, scrivere, chiudere, cancellare file
            Cambiare attributi (es. sola lettura)
            Il file system protegge i file con permessi di accesso (lettura, scrittura, esecuzione) e gestisce le code di accesso.

        Gestione dei Dispositivi Periferici üñ±Ô∏è‚å®Ô∏èüñ®Ô∏è
            L‚ÄôOS gestisce la comunicazione con periferiche (tastiere, stampanti, monitor).
            Usa una memoria buffer per ‚Äúparcheggiare‚Äù temporaneamente i dati in transito.
            Per ogni periferica esiste un driver che traduce le richieste dell‚ÄôOS in comandi per l‚Äôhardware.
            Gestisce la coda di richieste per evitare conflitti di accesso.

        Gestione della Memoria Secondaria üíæ
            Memoria secondaria = dischi, SSD, memorie persistenti (dati non volatili).
            Accesso pi√π lento rispetto alla RAM.
            L‚ÄôOS gestisce:
                Allocazione e deallocazione dello spazio
                Gestione dello spazio libero
                Ottimizzazione e serializzazione delle operazioni

        Gerarchia della Memoria üìä
            Registri CPU
            Cache
            Memoria principale (RAM)
            Memoria secondaria (dischi, SSD)
            Memoria esterna (dispositivi rimovibili)

        Protezione e Sicurezza üîê
            L‚ÄôOS garantisce privacy e sicurezza per utenti e risorse.
            Elementi chiave:
                Autenticazione: verifica dell‚Äôidentit√† (login con username e password).
                Autorizzazione: verifica dei permessi per accedere a risorse.

            Processi ereditano i permessi dell‚Äôutente associato.
            Utenti possono essere raggruppati in gruppi per semplificare i permessi.
            File e risorse hanno regole di accesso (lettura, scrittura, esecuzione).

        Interfacce Utente (HCI) üñ•Ô∏èüì±
            Interfaccia Alfanumerica: terminale che mostra testo e riceve input da tastiera.
            Interfaccia Grafica (GUI): finestre, icone, input da mouse o touchscreen.

========================================================================================================================================================================================


üì• LEZIONE 19: Modello TCP/IP
    Computer Networks: TCP/IP Model
        1. Introduzione al TCP/IP Model

            TCP/IP √® un modello a 4 livelli usato per standardizzare la comunicazione dati tra reti diverse, inclusa Internet.

            √à il modello di fatto per la comunicazione in rete, noto per la sua robustezza e flessibilit√†.

        2. Confronto tra ISO/OSI Model e TCP/IP Model
            Livello TCP/IP	Livello ISO/OSI	Funzione principale
            Application	Application, Presentation, Session	Fornisce servizi di rete direttamente alle applicazioni utente. Gestisce i protocolli applicativi.
            Transport	Transport	Gestisce la trasmissione dati affidabile o non affidabile tra host.
            Internet	Network	Gestisce l'indirizzamento e l'instradamento dei pacchetti dati.
            Network Access	Data Link, Physical	Gestisce l'accesso alla rete fisica, l'indirizzamento hardware, e la trasmissione fisica.
        3. Application Layer
            Funzioni:
                Fornisce servizi di rete alle applicazioni utente tramite vari protocolli.

        Principali protocolli e funzioni:
            DNS: Risoluzione dei nomi di dominio (es. www.cisco.com ‚Üí 198.133.219.25)
            HTTP/HTTPS: Navigazione web, con HTTPS che aggiunge sicurezza tramite crittografia
            FTP: Trasferimento file client-server
            SMTP/POP3/IMAP: Invio e ricezione email
            DHCP: Assegnazione automatica di indirizzi IP

        DNS (Domain Name System) ‚Äì Come funziona:
            Utente inserisce un dominio nel browser.
            Query inviata a un resolver DNS.
            Resolver contatta il root server per trovare il server TLD (.com, .org).
            Resolver contatta il server TLD per trovare il DNS autoritativo del dominio.
            Il server autoritativo fornisce l'indirizzo IP.
            Il resolver restituisce l‚Äôindirizzo IP al browser, che si connette al server web.

            HTTP / HTTPS
                HTTP: Protocollo per il trasferimento di pagine web.
                HTTPS: Estensione sicura di HTTP, cifra i dati scambiati.

        Processo tipico di navigazione:
            Inserimento URL ‚Üí 2. Risoluzione DNS ‚Üí 3. Connessione al server ‚Üí
            Invio richiesta GET ‚Üí 5. Ricezione risposta (HTML) ‚Üí 6. Rendering pagina.

        FTP (File Transfer Protocol)
            Usa due connessioni: controllo (comandi) e dati (file).
            Supporta autenticazione con username/password o accesso anonimo.

        Email Protocols
            SMTP: Invia email da client a server o tra server.
            POP3: Scarica email dal server al client e spesso cancella dal server.
            IMAP: Gestisce email direttamente sul server, sincronizzando pi√π dispositivi.
            DHCP (Dynamic Host Configuration Protocol)
                Assegna automaticamente indirizzi IP e altre configurazioni di rete.
                Processo: DHCPDISCOVER ‚Üí DHCPOFFER ‚Üí DHCPREQUEST ‚Üí DHCPACK.

        4. Transport Layer
            Funzioni:
                Gestisce la trasmissione dati affidabile o non affidabile tra host.

        Protocolli principali:
            TCP (Transmission Control Protocol): Connessione orientata, garantisce consegna senza errori e in ordine.
            UDP (User Datagram Protocol): Connessione senza garanzie, pi√π veloce, usato per streaming o giochi.

        TCP Header (campi principali)
            Source/Destination Port: identifica app mittente/destinataria
            Sequence Number: posizione dati
            Acknowledgment Number: conferma ricezione
            Flags: SYN (inizio connessione), ACK (conferma), FIN (fine connessione)
            Checksum: controllo errori

        UDP Header (campi principali)
            Source/Destination Port
            Length (header + dati)
            Checksum

        5. Internet Layer
            Funzioni:
                Indirizzamento logico e routing dei pacchetti dati.

        Protocolli principali:
            IP (Internet Protocol): instradamento dati (IPv4, IPv6).
            ICMP (Internet Control Message Protocol): messaggi di errore e diagnostica (es. ping).
            ARP (Address Resolution Protocol): associa indirizzi IP a indirizzi MAC.

        ICMP
            Usato per errori e diagnostica.
            Tipi comuni: Echo Request/Reply (ping), Destination Unreachable, Time Exceeded, Redirect.

        ARP
            Mappa un IP a un indirizzo MAC nella rete locale.
            Funziona tramite richieste broadcast e risposte unicast.
            Mantiene una cache con mappature temporanee.

        6. Network Access Layer
            Funzioni:
                Gestisce il livello fisico e di collegamento dati: trasmissione fisica, framing, indirizzamento hardware.

        Tecnologie comuni:
            Ethernet (LAN cablata)
            Wi-Fi (wireless)