üß† Progettazione Software ‚Äî (Analisti)
    üéØ Obiettivi del Corso

        ‚ùå Abbandonare l‚Äôintuizione :
            L‚Äôintuizione non basta nella progettazione software complessa.
            Serve invece pensiero analitico e ragionamento logico.

        ‚úÖ Competenze da acquisire :
            Progettare applicazioni software reali e non banali
            Dedicare molto tempo alla comprensione dei dati e delle loro interrelazioni
            Prendere decisioni ragionate, senza soluzioni uniche o ricette predefinite
            Adattare un metodo generale al problema specifico

        üß© Capacit√† da sviluppare :
            Ragionamento logico
            Valutazione delle alternative
            Scomposizione di problemi complessi in sottoproblemi

        üìå Esempio 1: Gestione Contatti :

            üîç Requisiti funzionali
                Memorizzare:
                    Nome e cognome
                    Numeri di telefono (casa, ufficio, cellulare)
                    Email

            Gestione dei gruppi di contatti
                Funzionalit√†:
                    Aggiungere, modificare, cancellare un contatto
                    Assegnare/rimuovere contatti da gruppi
                    Ricerca per nome/cognome

            üßë‚Äçüíª Considerazioni :
                Applicazione semplice ‚Üí pu√≤ essere gi√† implementata in Python
                Focus sulla modellazione dei dati, non solo sulla scrittura del codice

        üìå Esempio 2: Sistema Bancario :

            üéØ Obiettivo
                Gestire conti correnti, investimenti, promotori finanziari

            üîç Funzionalit√† richieste :
                Tracciare acquisti/vendite (azioni, obbligazioni‚Ä¶)
                Calcolare il valore aggiornato del portafoglio
                Assistere promotori finanziari nelle scelte
                Permettere ai responsabili di valutare i promotori

            üßë‚Äçüíº Stima di progetto (spannometrica) :
                Comprensione del problema: 6 mesi (33%)
                Progettazione: 9 mesi (50%)
                Realizzazione: 3 mesi (17%)

            üßë‚Äçüîß Attori Coinvolti nel Ciclo di Vita del Software :
                Committente: Cliente
                Esperti del dominio: Forniscono conoscenza specifica (es. leggi, regolamenti)
                Analisti: Studiano requisiti e rischi
                Progettisti: Definiscono l‚Äôarchitettura
                Programmatori: Front-end e Back-end
                Utenti finali: Usano l‚Äôapplicazione
                Manutentori: Gestiscono aggiornamenti e fix
    

üîÅ Ciclo di Vita del Software :

    1. Studio di Fattibilit√† üßê 
        Comprendere requisiti generali
        Valutare costi/benefici
        Pianificare tempi e risorse
        Scegliere ambiente hardware/software

    2. Raccolta Requisiti üìù 
        Intervistare gli attori
        Sintetizzare e raffinare i requisiti

    3. Analisi Concettuale dei Requisiti üìê
        Schema concettuale:
            Modello matematico dell'app
            Modella dati, relazioni, servizi offerti

        Non contiene scelte implementative

    4. Progetto (Design) üèóÔ∏è
        Definisce come realizzare le funzioni
        Scelte tecnologiche e architetturali
        Strutture dati in RAM e su disco

    5. Realizzazione (Implementazione) üíª
        Scrittura del codice
        Documentazione tecnica

    6. Integrazione e Verifica ‚úÖ
        Assemblaggio componenti
        Test di correttezza, completezza, efficienza

    7. Messa in Esercizio üöÄ
        Deploy dell'applicazione

    8. Manutenzione üîß
        Monitoraggio, aggiornamenti e fix

    üîÑ Modelli di Ciclo di Vita :

        ‚¨áÔ∏è Modello a Cascata (Waterfall)
            Ogni fase segue la precedente
            Utile solo a scopo didattico

        üîÑ Modello a Spirale (Iterativo)
            Fasi ripetute pi√π volte:
                Raccolta requisiti
                Analisi
                Design
                Realizzazione
                Verifica
                Manutenzione
            Ogni iterazione produce una versione migliorata

    üîÑ Confronto tra modelli di sviluppo :

        Puoi espandere un pochino il confronto tra Waterfall e Spirale:
        Modello	        Pro	                                        Contro
        ‚¨áÔ∏è Waterfall	Facile da pianificare e documentare,	    Rigidit√†, poco flessibile
        üîÑ Iterativo	Permette feedback continuo,	                Richiede buona gestione e test continui


üß∞ UML ‚Äì Unified Modeling Language :
    Linguaggio grafico standard per modellare applicazioni
    Unisce 3 linguaggi principali
    14 tipi di diagrammi totali

    üìä Tipi principali di diagrammi :
        üîπ Diagrammi Strutturali
            Class Diagram
            Object Diagram

        üîπ Diagrammi Comportamentali :
            Use Case Diagram
            State/Transition Diagram
            Sequence/Collaboration Diagram
            Activity Diagram

        üîπ Diagrammi Architetturali :
            Component Diagram
            Deployment Diagram

    üéØ Focus del Corso :
        Useremo:
            Class & Object Diagram
            Use Case Diagram
            State/Transition Diagram
            UML semplificato con regole precise

    üß± Oggetti in UML :
        Caratteristiche :
            Elemento con identit√† propria
            Ha un identificatore (es: div_comm)
            Istanza di una classe specifica
            Rappresentato come rettangolo diviso in 3 sezioni


    Esempio:

    -----------------
    |   div_comm    |   ‚Üê Identificatore (oggetto)
    -----------------
    |     Libro     |   ‚Üê Classe pi√π specifica
    -----------------
    |...attributi...|


üîß Esempi di Raffinamento Requisiti

    üè¢ Esempio Azienda :
        Requisiti Impiegati
            Nome, cognome, data di nascita
            Stipendio (real ‚â• 0)
            Dipartimento (uno solo)
            Progetti (possono essere molti)

        Requisiti Dipartimenti
            Nome, telefono
            Direttore (un impiegato)
            Elenco impiegati    

        Requisiti Progetti
            Nome, budget (real ‚â• 0)
            Elenco impiegati coinvolti


    ‚úàÔ∏è Esempio Voli Aerei :
        Requisiti Voli
            Codice (alfanumerico)
            Durata (ore e minuti)
            Compagnia aerea
            Aeroporti (partenza e arrivo)

        Requisiti Aeroporti
            Codice (4 caratteri)
            Nome
            Citt√†

        Requisiti Compagnie Aeree
            Nome, anno fondazione (>0)
            Citt√† sede

        Requisiti Citt√†
            Nome, nazione
            Numero abitanti (>0)
            Compagnie con sede nella citt√†


üèóÔ∏è Lezione 7 ‚Äì Fase di Design: (Progettista)

    1Ô∏è‚É£ Ristrutturare il diagramma delle classi
        Diagramma delle classi ristrutturato :
            Obiettivo: 
                - Traducibilit√† immediata in codice Python
                - Rendere il diagramma subito implementabile in Python

    2Ô∏è‚É£ Fare scelte tecnologiche
        Performance, sicurezza, scalabilit√†
            Sostituire:
                - Tipi concettuali con tipi supportati (es: String, int)
                - Generalizzazioni tra classi/associazioni non supportate

    3Ô∏è‚É£ Gestione tipi nei diagrammi
        - Tipi base: intero, reale, stringa
        - Tipi enumerativi: ad es. Genere = {Maschio, Femmina}
        - Tipi specializzati: Intero > 0, Stringa non vuota
        - Tipi composti: es. Indirizzo, CAP


    üìã 3 Step in ordine :

        1Ô∏è‚É£ Fare il designe dei tipi di dati :

            üî¢ Tipi base: 
                - intero : int 
                - reale : float 
                - stringa : str 
                - booleano : bool 
                - DataOra : datetime -> from datetime import datetime, date, time
                - Data : datetime.date -> from datetime import datetime, date, time
                - Ora : datetime.time -> from datetime import datetime, date, time

            üé≠ Tipi enumerativi: 
                - Genere : {Maschio, Femmina}
                    
                    Python :
                        from enum import StrEnum, auto

                        class Genere(StrEnum)
                            uomo = auto()
                            donna = auto()
                        
                    No Python:
                        class Genere:
                            _is_woman:bool

                            donna = Genere(True)
                            uomo = Genere(False)

                            def __init__(self, is_woman:bool):
                                self._is_woman = is_woman

                        class Persona:
                            _nome:str
                            _genere:Genere

                            def __init__(self, nome:str, genere:Genere):
                                self._nome = nome
                                self._genere = genere

                            def genere() -> Genere:
                                return self._genere

                        donna = Genere(True)
                        uomo = Genere(False)
                        ometto = Genere(False)

                        mario = Persona("mario", uomo)
                        anna = Persona("mario", donna)
                        aldo = Persona("mario", ometto)

                        print(mario.genere() == aldo.genere())  ->  # False!!!

            üß© Tipi specializzati: 
                - Intero > 0
                - Reale <= 0
                
            üèóÔ∏è Tipi composti: 
                - Indirizzo : 
                    from typing import Self

                    ‚úÖ class Indirizzo:
                        _via:str
                        _civico:int

                        def __init__(self, via:str, civico:int) -> Self:
                            self._via = via
                            self._civico = civico
                        
                        def via(self) -> str:
                            return self._via
                        
                        def civico(self) -> int:
                            return self._civico

                        def __str__(self) -> str:
                            return f"{self.via()}, {self.civico()}"

                        def __eq__(self, other) -> bool:
                            return (self.via(), self.civico() ) == (other.via(), other.civico())


                    if __name__ == '__main__':

                        i1 = Indirizzo("Via di casa mia", 35)
                        i2 = Indirizzo("Via di casa mia", 35)
                        print(i1)

                        print(i1 == i2) # True

                        l:list[indirizzo] = [i1]
                        print(i2 in l) # True

                - Voto : 
                    ‚ùå class VotoScorretto:
                        _v:int

                        def __init__(self, v:int) -> Voto:
                            if (v < 18 or v > 31):
                                raise ValueError("'v' deve essere tra 18 e 30")
                            self._v = v

                        def valore(self) -> int:
                            return self._v

                        # controllo di equaglianza
                        def __eq__(self, other) -> bool:
                            return self._v == other._v

                    # Main
                    v1:VotoScorretto = VotoScorretto(18)
                    v2:VotoScorretto = VotoScorretto(18)

                    v1 == v2 # !! PROBLEMI

                    ------------------------------------

                    # class int:
                    #    def __new__(v:int|str|float)
                    #        return ...
                    #
                    #    def __eq__(...): ---

                    ‚úÖ class VotoCorretto(int):
                        def __new__(cls, v:int|str|float) -> Self:
                            if (v < 18 or v > 31):
                                raise ValueError(f"Value v == {v} deve essere tra 18 e 30")
                            return int.__new__(cls, v)

                    # Main
                    v:Voto = Voto(19)  ->  # Vale 19
                    v2:Voto = Voto(v)  ->  # Vale v

                    v == v2 --> True !!!

        2Ô∏è‚É£ :

        3Ô∏è‚É£ :


üí° Conclusione :
    La progettazione software non √® solo scrivere codice, ma richiede:

        ‚úÖ Comprensione del dominio
        ‚úÖ Modellazione rigorosa
        ‚úÖ Scelte progettuali giustificate
        ‚úÖ Uso corretto di strumenti come UML
        ‚úÖ Pianificazione e valutazione continua