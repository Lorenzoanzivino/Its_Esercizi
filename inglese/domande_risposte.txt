Revision Questions: Chapters 1–10

1. What is computational thinking, and how does it differ from computer science
and programming?

    1.1. Computational thinking is a problem-solving process that involves abstraction, decomposition, algorithmic thinking, pattern recognition, modeling, and evaluation.
    In computer science, CT is the theoretical and practical study of computation.

2. Why is computational thinking considered relevant beyond the field of
computer science? Provide examples of other disciplines where it applies.

    2.1. Because it is a general method of problem solving.
    Examples:
    Biology: modeling ecosystems
    History: analyzing cause-effect chains

3. What are the core components of computational thinking as identified by Karl
Beecher, and how do they interact in problem-solving?

    3.1. Core components of CT include:
    ○ Logical thinking
    ○ Algorithmic thinking
    ○ Decomposition
    ○ Generalisation and pattern recognition
    ○ Abstraction
    ○ Modelling
    ○ Evaluation
    These work together to analyze problems, design solutions, and translate
    them into computational form.

4. What is the difference between deductive and inductive reasoning? Provide
examples of each in a computational context.

    4.1. Deductive : from general to detail.
    Example : All cycles repeat => the cycle for repeats.
    Inductive : from the particular to the general.
    Example : the for and while repeat => all cycles repeat operations.

5. How does Boolean logic support computational decision-making? Explain the
function of each major logical operator.

    5.1. Boolean logic is used for flow control (if, while).
    AND: True if both values are True
    OR: True if at least one value is True
    NOT: Inverts the logical value

6. What is symbolic logic, and why is it used instead of natural language in
computational contexts?

    6.1. Symbolic logic uses symbols such as: P and Q to be unambiguous
    Natural language is often vague.
    Computers require precision which is why symbolic logic is preferred.

7. What are the essential characteristics of an algorithm? How do sequence,
selection, and iteration contribute to algorithmic structure?

    7.1. Clear, finished, effective steps.
    The Structure is:
    Sequence: order of steps.
    Selection: conditions (if).
    Iteration: repetitions (loops).

8. Explain the concept of program state. Why is managing state crucial in
algorithm execution?

    8.1. State is set of values of variables at a time.
    Managing it is crucial for flow, correctness, and debugging.

9. What is decomposition, and why is it a valuable problem-solving strategy?
Provide an example of a decomposed problem.

    9.1. Decomposition is important because it divides a complex problem into simpler parts.
    - Prepare the ingredients (eggs, flour, sugar).
    - Mix the ingredients.
    - Bake the cake.
    - Let it cool.

10. What role does pattern recognition play in computational thinking? How does
it assist with generalization?

    10.1. The role of pattern recognition is important because it helps identify similarities in problems. It aids in generalizing reusable solutions for exemple sorting algorithm.

11. Define abstraction. How is it used to manage complexity in both
problem-solving and programming?

    11.1. Abstraction means simplifying a problem or a system, focusing only on the relevant aspects and ignoring complex details.
    in Problem solving helps to focus on the main aspects, simplifying the process.
    in Programming the Abstraction simplifies problems by hiding complex details, reducing complexity, and making problem-solving easier.


12. What is modelling in the context of computational thinking? Distinguish
between static and dynamic models.

    12.1. Modelling in the context of CT is the process of simplifying a problem to make it clearer.
    Static: representing a system that does not change over time, used to represent structure or fixed data.
    Dynamic: representing a system that changes over time, used for simulation.

13. What strategies can be used to anticipate, detect, and fix errors in a
computational solution?

    13.1. To anticipate, detect, and fix errors in a computational solution, you can use these strategies:
    Test the code: Run the code to check if it works correctly.
    Debugging: Analyze the code step by step to find and fix errors.
    Error handling: Use exception handling to prevent the program from crashing due to errors.
    Edge case testing: Test the code with unusual or unexpected inputs.
    Code review: Work with others to check the code and find any errors.

14. What is the role of testing in program development? Explain the difference
between verification and validation.

    14.1. Ensures that the code does exactly what it was written for, minimizing bugs.
    Check : Check that the program meets the specific requests, i.e. that it works as described in the initial project.
    Validation : Ensures that the program actually solves the problem for which it was created, not just that it works technically

15. How can a computational solution be evaluated in terms of correctness,
efficiency, usability, and elegance?

    15.1. A computational solution can be evaluated based on several factors. 
    Correctness : refers to whether the solution correctly solves the problem and provides the right results.
    Efficiency : is about how well the solution uses resources, such as time and memory, solving the problem in the fastest and most resource-effective way.
    Usability : focuses on how easy it is for the user to interact with the solution, ensuring the interfaces are simple and intuitive.
    Elegance : describes how well the solution is designed, being clear, readable, and free of unnecessary complexity.

16. What are some typical trade-offs encountered when designing a computational
solution?

    16.1. Speed vs. Memory : A very fast algorithm may require more memory, while one that uses less memory may be slower.

    Simplicity vs. Flexibility : A simple design is easier to understand and maintain, but it can be less flexible when you need to adapt to new requirements.

    Readability vs. Performance : A readable code is easier to change, but may not be the most performance-optimized. Sometimes, a compromise is necessary to achieve good efficiency without sacrificing comprehensibility too much.

17. How do variables and data types function in Python, and how are they aligned with the concepts of state and assignment?

    17.1. Variables represent the status of the program, i.e. the values retained during execution.
    Example: x is equal to 5 means that the variable x has a value 5.

    The data types define the nature of the data that a variable can contain.
    Example: int for whole numbers, str for text strings, lists for sorted sequences.

    The assignment allows you to change the status of the program, assigning new values to the variables.

18. What are the differences between mutable and immutable data types in Python,
and why do they matter in programming?

    18.1.Mutable: Items that can be modified after they were created.
    Example: Lists can be changed, you can add, remove, or edit items in a list.

    Immutable: Items that cannot be changed after creation.
    Example: Strings cannot be edited directly, but a new string must be created for each change.

    The difference is important especially in functions and cycles, where immutable data is safer because they do not change unexpectedly.

19. How do modules and packages help in organizing code? What are the benefits
of separating concerns in program structure?

    19.1. Modules are Python files that contain functions, classes, and variables. They allow you to separate the code into logical units.
    Example: math.py may contain mathematical functions.
    Packages are collections of modules, which further organize the code. A package can contain multiple modules and subpackages.
    Separating responsibilities makes the code more readable, maintainable, and reusable.

20. What is object-oriented programming, and how do abstractions like classes
and instances support pattern reuse in software design?

    20.1. Organize the code into classes (abstract models) that describe the behavior and properties of objects (instances).
    Abstraction: Classes hide complex details, allowing you to use the object without worrying about its internal implementation.
    Reuse: Thanks to inheritance, classes can extend and share features.
    Encapsulation: Protects the internal data of a class by making only certain information accessible, ensuring greater control.